-- Generated by Oracle SQL Developer Data Modeler 18.3.0.268.1156
--   at:        2018-12-02 02:32:54 MEZ
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g

-- TODO on generating new file:
-- search for END; and /CREATE + /ALTER. add newlines.
-- kit_items_briu trg not included, add!!!
-- locations_briu never made. create. also locations_jntrg never made. create.

DROP TABLE mwd.accessories CASCADE CONSTRAINTS;

DROP TABLE mwd.american_wire_gauges CASCADE CONSTRAINTS;

DROP TABLE mwd.attachments CASCADE CONSTRAINTS;

DROP TABLE mwd.beads CASCADE CONSTRAINTS;

DROP TABLE mwd.chains CASCADE CONSTRAINTS;

DROP TABLE mwd.clasps CASCADE CONSTRAINTS;

DROP TABLE mwd.colors CASCADE CONSTRAINTS;

DROP TABLE mwd.crafted_ingredients CASCADE CONSTRAINTS;

DROP TABLE mwd.created_items CASCADE CONSTRAINTS;

DROP TABLE mwd.domains CASCADE CONSTRAINTS;

DROP TABLE mwd.imperial_fractions CASCADE CONSTRAINTS;

DROP TABLE mwd.ingredients CASCADE CONSTRAINTS;

DROP TABLE mwd.item_ingredients CASCADE CONSTRAINTS;

DROP TABLE mwd.item_order_sources CASCADE CONSTRAINTS;

DROP TABLE mwd.item_weaves CASCADE CONSTRAINTS;

DROP TABLE mwd.items CASCADE CONSTRAINTS;

DROP TABLE mwd.jewelry CASCADE CONSTRAINTS;

DROP TABLE mwd.kit_items CASCADE CONSTRAINTS;

DROP TABLE mwd.kits CASCADE CONSTRAINTS;

DROP TABLE mwd.lace CASCADE CONSTRAINTS;

DROP TABLE mwd.legal_persons CASCADE CONSTRAINTS;

DROP TABLE mwd.location_addresses CASCADE CONSTRAINTS;

DROP TABLE mwd.locations CASCADE CONSTRAINTS;

DROP TABLE mwd.materials CASCADE CONSTRAINTS;

DROP TABLE mwd.natural_persons CASCADE CONSTRAINTS;

DROP TABLE mwd.order_items CASCADE CONSTRAINTS;

DROP TABLE mwd.orders CASCADE CONSTRAINTS;

DROP TABLE mwd.ornaments CASCADE CONSTRAINTS;

DROP TABLE mwd.other_ingredients CASCADE CONSTRAINTS;

DROP TABLE mwd.other_items CASCADE CONSTRAINTS;

DROP TABLE mwd.persons CASCADE CONSTRAINTS;

DROP TABLE mwd.purchases CASCADE CONSTRAINTS;

DROP TABLE mwd.raw_ingredients CASCADE CONSTRAINTS;

DROP TABLE mwd.rings CASCADE CONSTRAINTS;

DROP TABLE mwd.sales CASCADE CONSTRAINTS;

DROP TABLE mwd.scales CASCADE CONSTRAINTS;

DROP TABLE mwd.set_items CASCADE CONSTRAINTS;

DROP TABLE mwd.sets CASCADE CONSTRAINTS;

DROP TABLE mwd.standard_wire_gauges CASCADE CONSTRAINTS;

DROP TABLE mwd.store_items CASCADE CONSTRAINTS;

DROP TABLE mwd.stores CASCADE CONSTRAINTS;

DROP TABLE mwd.tools CASCADE CONSTRAINTS;

DROP TABLE mwd.weave_ars CASCADE CONSTRAINTS;

DROP TABLE mwd.weaves CASCADE CONSTRAINTS;

DROP TABLE mwd.wires CASCADE CONSTRAINTS;

DROP TABLE mwd.accessories_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.american_WIRE_GAUGES_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.attachments_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.beads_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.chains_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.clasps_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.colors_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.crafted_ingredients_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.created_items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.domains_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.imperial_fractions_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.ingredients_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.item_ingredients_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.item_order_sources_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.item_weaves_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.jewelry_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.kit_items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.kits_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.lace_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.legal_persons_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.location_addresses_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.locations_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.materials_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.natural_persons_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.order_items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.orders_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.ornaments_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.other_ingredients_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.other_items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.persons_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.purchases_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.raw_ingredients_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.rings_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.sales_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.scales_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.set_items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.sets_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.standard_WIRE_GAUGES_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.store_items_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.stores_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.tools_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.weave_ars_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.weaves_jn CASCADE CONSTRAINTS;

DROP TABLE mwd.wires_jn CASCADE CONSTRAINTS;

DROP SEQUENCE mwd.domn_seq;

DROP SEQUENCE mwd.item_ingr_seq;

DROP SEQUENCE mwd.item_ordr_srce_seq;

DROP SEQUENCE mwd.item_seq;

DROP SEQUENCE mwd.item_weav_seq;

DROP SEQUENCE mwd.kit_item_seq;

DROP SEQUENCE mwd.loc_addr_seq;

DROP SEQUENCE mwd.loc_seq;

DROP SEQUENCE mwd.mwd_cst_seq;

DROP SEQUENCE mwd.mwd_domn_seq;

DROP SEQUENCE mwd.mwd_event_log_seq;

DROP SEQUENCE mwd.mwd_ingr_seq;

DROP SEQUENCE mwd.mwd_kit_itm_seq;

DROP SEQUENCE mwd.mwd_kit_seq;

DROP SEQUENCE mwd.mwd_loc_seq;

DROP SEQUENCE mwd.mwd_ord_itm_seq;

DROP SEQUENCE mwd.mwd_ord_seq;

DROP SEQUENCE mwd.mwd_prod_ingr_seq;

DROP SEQUENCE mwd.mwd_prod_seq;

DROP SEQUENCE mwd.mwd_prod_weav_seq;

DROP SEQUENCE mwd.mwd_set_itm_seq;

DROP SEQUENCE mwd.mwd_set_seq;

DROP SEQUENCE mwd.mwd_str_pro_seq;

DROP SEQUENCE mwd.mwd_str_seq;

DROP SEQUENCE mwd.mwd_weav_seq;

DROP SEQUENCE mwd.ordr_item_seq;

DROP SEQUENCE mwd.ordr_seq;

DROP SEQUENCE mwd.pers_seq;

DROP SEQUENCE mwd.set_item_seq;

DROP SEQUENCE mwd.stor_item_seq;

DROP SEQUENCE mwd.stor_seq;

DROP SEQUENCE mwd.weav_ar_seq;

DROP SEQUENCE mwd.weav_seq;

CREATE SEQUENCE mwd.domn_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.item_ingr_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.item_ordr_srce_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.item_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.item_weav_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.kit_item_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.loc_addr_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.loc_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_cst_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_domn_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_event_log_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_ingr_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_kit_itm_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_kit_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_loc_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_ord_itm_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_ord_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_prod_ingr_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_prod_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_prod_weav_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_set_itm_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_set_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_str_pro_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_str_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.mwd_weav_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.ordr_item_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.ordr_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.pers_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.set_item_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.stor_item_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.stor_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.weav_ar_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE SEQUENCE mwd.weav_seq INCREMENT BY 1 MAXVALUE 9999999999999999999999999999 MINVALUE 1 CACHE 20;

CREATE TABLE mwd.accessories (
    created_item_id   NUMBER NOT NULL,
    accessory_type    VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.accessories_pk ON
    mwd.accessories (
        created_item_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.accessories
    ADD CONSTRAINT accessories_pk PRIMARY KEY ( created_item_id )
        USING INDEX mwd.accessories_pk;


CREATE TABLE MWD.ACCESSORIES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CREATED_ITEM_ID NUMBER NOT NULL
 ,ACCESSORY_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.ACCESSORIES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ACCESSORIES for each row 
 Declare 
  rec MWD.ACCESSORIES_JN%ROWTYPE; 
  blank MWD.ACCESSORIES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CREATED_ITEM_ID := :NEW.CREATED_ITEM_ID; 
      rec.ACCESSORY_TYPE := :NEW.ACCESSORY_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CREATED_ITEM_ID := :OLD.CREATED_ITEM_ID; 
      rec.ACCESSORY_TYPE := :OLD.ACCESSORY_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ACCESSORIES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.american_wire_gauges (
    awg_id          NUMBER NOT NULL,
    awg             VARCHAR2(30 BYTE),
    inch_diameter   NUMBER(10, 4),
    diameter_mm     NUMBER(10, 4)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.american_wire_gauges_pk ON
    mwd.american_wire_gauges (
        awg_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.american_wire_gauges_uk ON
    mwd.american_wire_gauges (
        awg
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.american_wire_gauge
    ADD CONSTRAINT american_wire_gauges_pk PRIMARY KEY ( awg_id )
        USING INDEX mwd.american_wire_gauges_pk;

ALTER TABLE mwd.american_wire_gauge
    ADD CONSTRAINT american_wire_gauges_uk UNIQUE ( awg )
        USING INDEX mwd.american_wire_gauges_uk;


CREATE TABLE MWD.AMERICAN_WIRE_GAUGES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,AWG_ID NUMBER NOT NULL
 ,AWG VARCHAR2 (30 BYTE)
 ,INCH_DIAMETER NUMBER (10,4)
 ,DIAMETER_MM NUMBER (10,4)
 );

CREATE OR REPLACE TRIGGER MWD.AMERICAN_WIRE_GAUGES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.AMERICAN_WIRE_GAUGES for each row 
 Declare 
  rec MWD.AMERICAN_WIRE_GAUGES_JN%ROWTYPE; 
  blank MWD.AMERICAN_WIRE_GAUGES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.AWG_ID := :NEW.AWG_ID; 
      rec.AWG := :NEW.AWG; 
      rec.INCH_DIAMETER := :NEW.INCH_DIAMETER; 
      rec.DIAMETER_MM := :NEW.DIAMETER_MM; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.AWG_ID := :OLD.AWG_ID; 
      rec.AWG := :OLD.AWG; 
      rec.INCH_DIAMETER := :OLD.INCH_DIAMETER; 
      rec.DIAMETER_MM := :OLD.DIAMETER_MM; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.AMERICAN_WIRE_GAUGES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.attachments (
    attachment_id     NUMBER NOT NULL,
    attachment_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.attachments_pk ON
    mwd.attachments (
        attachment_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.attachments
    ADD CONSTRAINT attachments_pk PRIMARY KEY ( attachment_id )
        USING INDEX mwd.attachments_pk;


CREATE TABLE MWD.ATTACHMENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ATTACHMENT_ID NUMBER NOT NULL
 ,ATTACHMENT_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.ATTACHMENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ATTACHMENTS for each row 
 Declare 
  rec MWD.ATTACHMENTS_JN%ROWTYPE; 
  blank MWD.ATTACHMENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ATTACHMENT_ID := :NEW.ATTACHMENT_ID; 
      rec.ATTACHMENT_TYPE := :NEW.ATTACHMENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ATTACHMENT_ID := :OLD.ATTACHMENT_ID; 
      rec.ATTACHMENT_TYPE := :OLD.ATTACHMENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ATTACHMENTS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.beads (
    bead_id     NUMBER NOT NULL,
    bead_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.beads_pk ON
    mwd.beads (
        bead_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.beads
    ADD CONSTRAINT beads_pk PRIMARY KEY ( bead_id )
        USING INDEX mwd.beads_pk;


CREATE TABLE MWD.BEADS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,BEAD_ID NUMBER NOT NULL
 ,BEAD_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.BEADS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.BEADS for each row 
 Declare 
  rec MWD.BEADS_JN%ROWTYPE; 
  blank MWD.BEADS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.BEAD_ID := :NEW.BEAD_ID; 
      rec.BEAD_TYPE := :NEW.BEAD_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.BEAD_ID := :OLD.BEAD_ID; 
      rec.BEAD_TYPE := :OLD.BEAD_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.BEADS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.chains (
    chain_id     NUMBER NOT NULL,
    chain_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.chains_pk ON
    mwd.chains (
        chain_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.chains
    ADD CONSTRAINT chains_pk PRIMARY KEY ( chain_id )
        USING INDEX mwd.chains_pk;


CREATE TABLE MWD.CHAINS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CHAIN_ID NUMBER NOT NULL
 ,CHAIN_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.CHAINS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.CHAINS for each row 
 Declare 
  rec MWD.CHAINS_JN%ROWTYPE; 
  blank MWD.CHAINS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CHAIN_ID := :NEW.CHAIN_ID; 
      rec.CHAIN_TYPE := :NEW.CHAIN_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CHAIN_ID := :OLD.CHAIN_ID; 
      rec.CHAIN_TYPE := :OLD.CHAIN_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.CHAINS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.clasps (
    clasp_id     NUMBER NOT NULL,
    clasp_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.clasps_pk ON
    mwd.clasps (
        clasp_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.clasps
    ADD CONSTRAINT clasps_pk PRIMARY KEY ( clasp_id )
        USING INDEX mwd.clasps_pk;


CREATE TABLE MWD.CLASPS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CLASP_ID NUMBER NOT NULL
 ,CLASP_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.CLASPS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.CLASPS for each row 
 Declare 
  rec MWD.CLASPS_JN%ROWTYPE; 
  blank MWD.CLASPS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CLASP_ID := :NEW.CLASP_ID; 
      rec.CLASP_TYPE := :NEW.CLASP_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CLASP_ID := :OLD.CLASP_ID; 
      rec.CLASP_TYPE := :OLD.CLASP_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.CLASPS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.colors (
    name          VARCHAR2(45 BYTE) NOT NULL,
    base_color    VARCHAR2(45 BYTE),
    tint          VARCHAR2(45 BYTE),
    color_type    VARCHAR2(45 BYTE),
    added_color   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.colors_pk ON
    mwd.colors (
        name
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.colors
    ADD CONSTRAINT colors_pk PRIMARY KEY ( name )
        USING INDEX mwd.colors_pk;


CREATE TABLE MWD.COLORS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,NAME VARCHAR2 (45 BYTE) NOT NULL
 ,BASE_COLOR VARCHAR2 (45 BYTE)
 ,TINT VARCHAR2 (45 BYTE)
 ,COLOR_TYPE VARCHAR2 (45 BYTE)
 ,ADDED_COLOR VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.COLORS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.COLORS for each row 
 Declare 
  rec MWD.COLORS_JN%ROWTYPE; 
  blank MWD.COLORS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.NAME := :NEW.NAME; 
      rec.BASE_COLOR := :NEW.BASE_COLOR; 
      rec.TINT := :NEW.TINT; 
      rec.COLOR_TYPE := :NEW.COLOR_TYPE; 
      rec.ADDED_COLOR := :NEW.ADDED_COLOR; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.NAME := :OLD.NAME; 
      rec.BASE_COLOR := :OLD.BASE_COLOR; 
      rec.TINT := :OLD.TINT; 
      rec.COLOR_TYPE := :OLD.COLOR_TYPE; 
      rec.ADDED_COLOR := :OLD.ADDED_COLOR; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.COLORS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.crafted_ingredients (
    crafted_ingredient_id          NUMBER NOT NULL,
    crafted_ingredient_type        VARCHAR2(45 BYTE),
    raw_ingredient_id              NUMBER,
    raw_ingredient_weight_amount   NUMBER(10, 4)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.crafted_ingredients_pk ON
    mwd.crafted_ingredients (
        crafted_ingredient_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.crafted_ingredients
    ADD CONSTRAINT crafted_ingredients_pk PRIMARY KEY ( crafted_ingredient_id )
        USING INDEX mwd.crafted_ingredients_pk;


CREATE TABLE MWD.CRAFTED_INGREDIENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CRAFTED_INGREDIENT_ID NUMBER NOT NULL
 ,CRAFTED_INGREDIENT_TYPE VARCHAR2 (45 BYTE)
 ,RAW_INGREDIENT_ID NUMBER
 ,RAW_INGREDIENT_WEIGHT_AMOUNT NUMBER (10,4)
 );

CREATE OR REPLACE TRIGGER MWD.CRAFTED_INGREDIENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.CRAFTED_INGREDIENTS for each row 
 Declare 
  rec MWD.CRAFTED_INGREDIENTS_JN%ROWTYPE; 
  blank MWD.CRAFTED_INGREDIENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CRAFTED_INGREDIENT_ID := :NEW.CRAFTED_INGREDIENT_ID; 
      rec.CRAFTED_INGREDIENT_TYPE := :NEW.CRAFTED_INGREDIENT_TYPE; 
      rec.RAW_INGREDIENT_ID := :NEW.RAW_INGREDIENT_ID; 
      rec.RAW_INGREDIENT_WEIGHT_AMOUNT := :NEW.RAW_INGREDIENT_WEIGHT_AMOUNT; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CRAFTED_INGREDIENT_ID := :OLD.CRAFTED_INGREDIENT_ID; 
      rec.CRAFTED_INGREDIENT_TYPE := :OLD.CRAFTED_INGREDIENT_TYPE; 
      rec.RAW_INGREDIENT_ID := :OLD.RAW_INGREDIENT_ID; 
      rec.RAW_INGREDIENT_WEIGHT_AMOUNT := :OLD.RAW_INGREDIENT_WEIGHT_AMOUNT; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.CRAFTED_INGREDIENTS_JN VALUES rec; 
  END; 
/

  
CREATE TABLE mwd.created_items (
    created_item_id     NUMBER NOT NULL,
    created_item_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.created_items_pk ON
    mwd.created_items (
        created_item_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.created_items
    ADD CONSTRAINT created_items_pk PRIMARY KEY ( created_item_id )
        USING INDEX mwd.created_items_pk;


CREATE TABLE MWD.CREATED_ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CREATED_ITEM_ID NUMBER NOT NULL
 ,CREATED_ITEM_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.CREATED_ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.CREATED_ITEMS for each row 
 Declare 
  rec MWD.CREATED_ITEMS_JN%ROWTYPE; 
  blank MWD.CREATED_ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CREATED_ITEM_ID := :NEW.CREATED_ITEM_ID; 
      rec.CREATED_ITEM_TYPE := :NEW.CREATED_ITEM_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CREATED_ITEM_ID := :OLD.CREATED_ITEM_ID; 
      rec.CREATED_ITEM_TYPE := :OLD.CREATED_ITEM_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.CREATED_ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.domains (
    domain_value_id          NUMBER NOT NULL,
    domain_value             VARCHAR2(100 BYTE) NOT NULL,
    domain_name              VARCHAR2(100 BYTE) NOT NULL,
    domain_refloc            VARCHAR2(100 BYTE) DEFAULT 'UNKNOWN' NOT NULL,
    sort_order               NUMBER NOT NULL,
    parent_domain_value_id   NUMBER,
    description              VARCHAR2(2000 BYTE),
    domain_type              VARCHAR2(30 BYTE) DEFAULT 'LIST_OF_VALUES' NOT NULL,
    active                   CHAR(1 BYTE) DEFAULT 'Y' NOT NULL,
    user_created             VARCHAR2(30 BYTE) NOT NULL,
    date_created             DATE NOT NULL,
    user_modified            VARCHAR2(30 BYTE) NOT NULL,
    date_modified            DATE NOT NULL
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.domains_pk ON
    mwd.domains (
        domain_value_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.domains_uk ON
    mwd.domains (
        domain_name
    ASC,
        domain_value
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.domains
    ADD CONSTRAINT domains_pk PRIMARY KEY ( domain_value_id )
        USING INDEX mwd.domains_pk;

ALTER TABLE mwd.domains
    ADD CONSTRAINT domains_uk UNIQUE ( domain_name,
                                       domain_value )
        USING INDEX mwd.domains_uk;


CREATE TABLE MWD.DOMAINS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,DOMAIN_VALUE_ID NUMBER NOT NULL
 ,DOMAIN_VALUE VARCHAR2 (100 BYTE) NOT NULL
 ,DOMAIN_NAME VARCHAR2 (100 BYTE) NOT NULL
 ,DOMAIN_REFLOC VARCHAR2 (100 BYTE) NOT NULL
 ,SORT_ORDER NUMBER NOT NULL
 ,PARENT_DOMAIN_VALUE_ID NUMBER
 ,DESCRIPTION VARCHAR2 (2000 BYTE)
 ,DOMAIN_TYPE VARCHAR2 (30 BYTE) NOT NULL
 ,ACTIVE CHAR (1 BYTE) NOT NULL
 ,USER_CREATED VARCHAR2 (30 BYTE) NOT NULL
 ,DATE_CREATED DATE NOT NULL
 ,USER_MODIFIED VARCHAR2 (30 BYTE) NOT NULL
 ,DATE_MODIFIED DATE NOT NULL
 );

CREATE OR REPLACE TRIGGER MWD.DOMAINS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.DOMAINS for each row 
 Declare 
  rec MWD.DOMAINS_JN%ROWTYPE; 
  blank MWD.DOMAINS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.DOMAIN_VALUE_ID := :NEW.DOMAIN_VALUE_ID; 
      rec.DOMAIN_VALUE := :NEW.DOMAIN_VALUE; 
      rec.DOMAIN_NAME := :NEW.DOMAIN_NAME; 
      rec.DOMAIN_REFLOC := :NEW.DOMAIN_REFLOC; 
      rec.SORT_ORDER := :NEW.SORT_ORDER; 
      rec.PARENT_DOMAIN_VALUE_ID := :NEW.PARENT_DOMAIN_VALUE_ID; 
      rec.DESCRIPTION := :NEW.DESCRIPTION; 
      rec.DOMAIN_TYPE := :NEW.DOMAIN_TYPE; 
      rec.ACTIVE := :NEW.ACTIVE; 
      rec.USER_CREATED := :NEW.USER_CREATED; 
      rec.DATE_CREATED := :NEW.DATE_CREATED; 
      rec.USER_MODIFIED := :NEW.USER_MODIFIED; 
      rec.DATE_MODIFIED := :NEW.DATE_MODIFIED; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.DOMAIN_VALUE_ID := :OLD.DOMAIN_VALUE_ID; 
      rec.DOMAIN_VALUE := :OLD.DOMAIN_VALUE; 
      rec.DOMAIN_NAME := :OLD.DOMAIN_NAME; 
      rec.DOMAIN_REFLOC := :OLD.DOMAIN_REFLOC; 
      rec.SORT_ORDER := :OLD.SORT_ORDER; 
      rec.PARENT_DOMAIN_VALUE_ID := :OLD.PARENT_DOMAIN_VALUE_ID; 
      rec.DESCRIPTION := :OLD.DESCRIPTION; 
      rec.DOMAIN_TYPE := :OLD.DOMAIN_TYPE; 
      rec.ACTIVE := :OLD.ACTIVE; 
      rec.USER_CREATED := :OLD.USER_CREATED; 
      rec.DATE_CREATED := :OLD.DATE_CREATED; 
      rec.USER_MODIFIED := :OLD.USER_MODIFIED; 
      rec.DATE_MODIFIED := :OLD.DATE_MODIFIED; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.DOMAINS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.imperial_fractions (
    inch_fraction   VARCHAR2(30 BYTE) NOT NULL,
    inch_diameter   NUMBER(10, 4),
    diameter_mm     NUMBER(10, 4)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.imperial_fractions_pk ON
    mwd.imperial_fractions (
        inch_fraction
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.imperial_fractions
    ADD CONSTRAINT imperial_fractions_pk PRIMARY KEY ( inch_fraction )
        USING INDEX mwd.imperial_fractions_pk;


CREATE TABLE MWD.IMPERIAL_FRACTIONS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,INCH_FRACTION VARCHAR2 (30 BYTE) NOT NULL
 ,INCH_DIAMETER NUMBER (10,4)
 ,DIAMETER_MM NUMBER (10,4)
 );

CREATE OR REPLACE TRIGGER MWD.IMPERIAL_FRACTIONS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.IMPERIAL_FRACTIONS for each row 
 Declare 
  rec MWD.IMPERIAL_FRACTIONS_JN%ROWTYPE; 
  blank MWD.IMPERIAL_FRACTIONS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.INCH_FRACTION := :NEW.INCH_FRACTION; 
      rec.INCH_DIAMETER := :NEW.INCH_DIAMETER; 
      rec.DIAMETER_MM := :NEW.DIAMETER_MM; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.INCH_FRACTION := :OLD.INCH_FRACTION; 
      rec.INCH_DIAMETER := :OLD.INCH_DIAMETER; 
      rec.DIAMETER_MM := :OLD.DIAMETER_MM; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.IMPERIAL_FRACTIONS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.ingredients (
    ingredient_id         NUMBER NOT NULL,
    material              VARCHAR2(45 BYTE) DEFAULT 'OTHER',
    color                 VARCHAR2(45 BYTE) DEFAULT 'NATURAL',
    wire_diameter_mm      NUMBER(8, 2),
    inner_diameter_mm     NUMBER(8, 2),
    outer_diameter_mm     NUMBER(8, 2),
    aspect_ratio          NUMBER(8, 2),
    opening_diameter_mm   NUMBER(8, 2),
    ingredient_type       VARCHAR2(45 BYTE),
    wire_diameter_swg     VARCHAR2(30 BYTE),
    wire_diameter_awg     VARCHAR2(30 BYTE),
    inner_diameter_inch   VARCHAR2(45 BYTE)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.ingredients_pk ON
    mwd.ingredients (
        ingredient_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.ingredients_uk ON
    mwd.ingredients (
        material
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_pk PRIMARY KEY ( ingredient_id )
        USING INDEX mwd.ingredients_pk;


CREATE TABLE MWD.INGREDIENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,INGREDIENT_ID NUMBER NOT NULL
 ,MATERIAL VARCHAR2 (45 BYTE)
 ,COLOR VARCHAR2 (45 BYTE)
 ,WIRE_DIAMETER_MM NUMBER (8,2)
 ,INNER_DIAMETER_MM NUMBER (8,2)
 ,OUTER_DIAMETER_MM NUMBER (8,2)
 ,ASPECT_RATIO NUMBER (8,2)
 ,OPENING_DIAMETER_MM NUMBER (8,2)
 ,INGREDIENT_TYPE VARCHAR2 (45 BYTE)
 ,WIRE_DIAMETER_SWG VARCHAR2 (30 BYTE)
 ,WIRE_DIAMETER_AWG VARCHAR2 (30 BYTE)
 ,INNER_DIAMETER_INCH VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.INGREDIENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.INGREDIENTS for each row 
 Declare 
  rec MWD.INGREDIENTS_JN%ROWTYPE; 
  blank MWD.INGREDIENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.INGREDIENT_ID := :NEW.INGREDIENT_ID; 
      rec.MATERIAL := :NEW.MATERIAL; 
      rec.COLOR := :NEW.COLOR; 
      rec.WIRE_DIAMETER_MM := :NEW.WIRE_DIAMETER_MM; 
      rec.INNER_DIAMETER_MM := :NEW.INNER_DIAMETER_MM; 
      rec.OUTER_DIAMETER_MM := :NEW.OUTER_DIAMETER_MM; 
      rec.ASPECT_RATIO := :NEW.ASPECT_RATIO; 
      rec.OPENING_DIAMETER_MM := :NEW.OPENING_DIAMETER_MM; 
      rec.INGREDIENT_TYPE := :NEW.INGREDIENT_TYPE; 
      rec.WIRE_DIAMETER_SWG := :NEW.WIRE_DIAMETER_SWG; 
      rec.WIRE_DIAMETER_AWG := :NEW.WIRE_DIAMETER_AWG; 
      rec.INNER_DIAMETER_INCH := :NEW.INNER_DIAMETER_INCH; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.INGREDIENT_ID := :OLD.INGREDIENT_ID; 
      rec.MATERIAL := :OLD.MATERIAL; 
      rec.COLOR := :OLD.COLOR; 
      rec.WIRE_DIAMETER_MM := :OLD.WIRE_DIAMETER_MM; 
      rec.INNER_DIAMETER_MM := :OLD.INNER_DIAMETER_MM; 
      rec.OUTER_DIAMETER_MM := :OLD.OUTER_DIAMETER_MM; 
      rec.ASPECT_RATIO := :OLD.ASPECT_RATIO; 
      rec.OPENING_DIAMETER_MM := :OLD.OPENING_DIAMETER_MM; 
      rec.INGREDIENT_TYPE := :OLD.INGREDIENT_TYPE; 
      rec.WIRE_DIAMETER_SWG := :OLD.WIRE_DIAMETER_SWG; 
      rec.WIRE_DIAMETER_AWG := :OLD.WIRE_DIAMETER_AWG; 
      rec.INNER_DIAMETER_INCH := :OLD.INNER_DIAMETER_INCH; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.INGREDIENTS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.item_ingredients (
    item_ingredient_id   NUMBER(3) NOT NULL,
    item_id              NUMBER NOT NULL,
    ingredient_id        NUMBER NOT NULL,
    unit_price           NUMBER(8, 2) DEFAULT 0,
    quantity             NUMBER(8) DEFAULT 0
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.item_ingredients_pk ON
    mwd.item_ingredients (
        item_ingredient_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.item_ingredients_uk ON
    mwd.item_ingredients (
        item_id
    ASC,
        ingredient_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.item_ingredients
    ADD CONSTRAINT item_ingredients_pk PRIMARY KEY ( item_ingredient_id )
        USING INDEX mwd.item_ingredients_pk;

ALTER TABLE mwd.item_ingredients
    ADD CONSTRAINT item_ingredients_uk UNIQUE ( item_id,
                                                ingredient_id )
        USING INDEX mwd.item_ingredients_uk;


CREATE TABLE MWD.ITEM_INGREDIENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ITEM_INGREDIENT_ID NUMBER (3) NOT NULL
 ,ITEM_ID NUMBER NOT NULL
 ,INGREDIENT_ID NUMBER NOT NULL
 ,UNIT_PRICE NUMBER (8,2)
 ,QUANTITY NUMBER (8)
 );

CREATE OR REPLACE TRIGGER MWD.ITEM_INGREDIENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ITEM_INGREDIENTS for each row 
 Declare 
  rec MWD.ITEM_INGREDIENTS_JN%ROWTYPE; 
  blank MWD.ITEM_INGREDIENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ITEM_INGREDIENT_ID := :NEW.ITEM_INGREDIENT_ID; 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.INGREDIENT_ID := :NEW.INGREDIENT_ID; 
      rec.UNIT_PRICE := :NEW.UNIT_PRICE; 
      rec.QUANTITY := :NEW.QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ITEM_INGREDIENT_ID := :OLD.ITEM_INGREDIENT_ID; 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.INGREDIENT_ID := :OLD.INGREDIENT_ID; 
      rec.UNIT_PRICE := :OLD.UNIT_PRICE; 
      rec.QUANTITY := :OLD.QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ITEM_INGREDIENTS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.item_order_sources (
    item_order_source_id   NUMBER NOT NULL,
    item_id                NUMBER NOT NULL,
    source_productcode     VARCHAR2(45 BYTE),
    source_unit_price      NUMBER(8, 2) DEFAULT 0,
    source_amount          NUMBER DEFAULT 0,
    source_brand           VARCHAR2(500 BYTE),
    source_order_url       VARCHAR2(2000 BYTE),
    modified_date          TIMESTAMP WITH LOCAL TIME ZONE
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.item_order_sources_pk ON
    mwd.item_order_sources (
        item_id
    ASC )
        TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.item_order_sources_un ON
    mwd.item_order_sources (
        item_id
    ASC,
        source_productcode
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.item_order_sources_un2 ON
    mwd.item_order_sources (
        source_productcode
    ASC,
        source_brand
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.item_order_sources
    ADD CONSTRAINT item_order_sources_un UNIQUE ( item_id,
                                                  source_productcode )
        USING INDEX mwd.item_order_sources_un;

ALTER TABLE mwd.item_order_sources
    ADD CONSTRAINT item_order_sources_un2 UNIQUE ( source_productcode,
                                                   source_brand )
        USING INDEX mwd.item_order_sources_un2;


CREATE TABLE MWD.ITEM_ORDER_SOURCES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ITEM_ORDER_SOURCE_ID NUMBER NOT NULL
 ,ITEM_ID NUMBER NOT NULL
 ,SOURCE_PRODUCTCODE VARCHAR2 (45 BYTE)
 ,SOURCE_UNIT_PRICE NUMBER (8,2)
 ,SOURCE_AMOUNT NUMBER
 ,SOURCE_BRAND VARCHAR2 (500 BYTE)
 ,SOURCE_ORDER_URL VARCHAR2 (2000 BYTE)
 ,MODIFIED_DATE TIMESTAMP WITH LOCAL TIME ZONE
 );

CREATE OR REPLACE TRIGGER MWD.ITEM_ORDER_SOURCES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ITEM_ORDER_SOURCES for each row 
 Declare 
  rec MWD.ITEM_ORDER_SOURCES_JN%ROWTYPE; 
  blank MWD.ITEM_ORDER_SOURCES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ITEM_ORDER_SOURCE_ID := :NEW.ITEM_ORDER_SOURCE_ID; 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.SOURCE_PRODUCTCODE := :NEW.SOURCE_PRODUCTCODE; 
      rec.SOURCE_UNIT_PRICE := :NEW.SOURCE_UNIT_PRICE; 
      rec.SOURCE_AMOUNT := :NEW.SOURCE_AMOUNT; 
      rec.SOURCE_BRAND := :NEW.SOURCE_BRAND; 
      rec.SOURCE_ORDER_URL := :NEW.SOURCE_ORDER_URL; 
      rec.MODIFIED_DATE := :NEW.MODIFIED_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ITEM_ORDER_SOURCE_ID := :OLD.ITEM_ORDER_SOURCE_ID; 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.SOURCE_PRODUCTCODE := :OLD.SOURCE_PRODUCTCODE; 
      rec.SOURCE_UNIT_PRICE := :OLD.SOURCE_UNIT_PRICE; 
      rec.SOURCE_AMOUNT := :OLD.SOURCE_AMOUNT; 
      rec.SOURCE_BRAND := :OLD.SOURCE_BRAND; 
      rec.SOURCE_ORDER_URL := :OLD.SOURCE_ORDER_URL; 
      rec.MODIFIED_DATE := :OLD.MODIFIED_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ITEM_ORDER_SOURCES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.item_weaves (
    item_weave_id   NUMBER NOT NULL,
    item_id         NUMBER NOT NULL,
    weave_id        NUMBER NOT NULL,
    ingredient_id   NUMBER,
    ring_quantity   NUMBER DEFAULT 1
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.item_weaves_pk ON
    mwd.item_weaves (
        item_weave_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.item_weaves_uk ON
    mwd.item_weaves (
        item_id
    ASC,
        weave_id
    ASC,
        ingredient_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.item_weaves
    ADD CONSTRAINT item_weaves_pk PRIMARY KEY ( item_weave_id )
        USING INDEX mwd.item_weaves_pk;

ALTER TABLE mwd.item_weaves
    ADD CONSTRAINT item_weaves_uk UNIQUE ( item_id,
                                           weave_id,
                                           ingredient_id )
        USING INDEX mwd.item_weaves_uk;


CREATE TABLE MWD.ITEM_WEAVES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ITEM_WEAVE_ID NUMBER NOT NULL
 ,ITEM_ID NUMBER NOT NULL
 ,WEAVE_ID NUMBER NOT NULL
 ,INGREDIENT_ID NUMBER
 ,RING_QUANTITY NUMBER
 );

CREATE OR REPLACE TRIGGER MWD.ITEM_WEAVES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ITEM_WEAVES for each row 
 Declare 
  rec MWD.ITEM_WEAVES_JN%ROWTYPE; 
  blank MWD.ITEM_WEAVES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ITEM_WEAVE_ID := :NEW.ITEM_WEAVE_ID; 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.WEAVE_ID := :NEW.WEAVE_ID; 
      rec.INGREDIENT_ID := :NEW.INGREDIENT_ID; 
      rec.RING_QUANTITY := :NEW.RING_QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ITEM_WEAVE_ID := :OLD.ITEM_WEAVE_ID; 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.WEAVE_ID := :OLD.WEAVE_ID; 
      rec.INGREDIENT_ID := :OLD.INGREDIENT_ID; 
      rec.RING_QUANTITY := :OLD.RING_QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ITEM_WEAVES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.items (
    item_id            NUMBER NOT NULL,
    name               VARCHAR2(30 BYTE) NOT NULL,
    list_price         NUMBER(8, 2) DEFAULT 0,
    availability       VARCHAR2(30 BYTE) DEFAULT 'IN_STOCK',
    sale_status        VARCHAR2(30 BYTE) DEFAULT 'NONE',
    item_type          VARCHAR2(45 BYTE),
    description        VARCHAR2(2000 BYTE),
    cost_total         NUMBER(8, 2) DEFAULT 0,
    time_min           NUMBER DEFAULT 0,
    length_mm          NUMBER(8, 2),
    width_mm           NUMBER(8, 2),
    thickness_mm       NUMBER(8, 2),
    height_mm          NUMBER(8, 2),
    weight_gr          NUMBER(8, 2),
    current_amount     NUMBER,
    purchased_amount   NUMBER
)
TABLESPACE bp NOLOGGING;

CREATE INDEX mwd.items_ix ON
    mwd.items (
        sale_status
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE INDEX mwd.items_ix2 ON
    mwd.items (
        item_type
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.items_pk ON
    mwd.items (
        item_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.items_uk ON
    mwd.items (
        name
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.items
    ADD CONSTRAINT items_pk PRIMARY KEY ( item_id )
        USING INDEX mwd.items_pk;

ALTER TABLE mwd.items
    ADD CONSTRAINT items_uk UNIQUE ( name )
        USING INDEX mwd.items_uk;


CREATE TABLE MWD.ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ITEM_ID NUMBER NOT NULL
 ,NAME VARCHAR2 (30 BYTE) NOT NULL
 ,LIST_PRICE NUMBER (8,2)
 ,AVAILABILITY VARCHAR2 (30 BYTE)
 ,SALE_STATUS VARCHAR2 (30 BYTE)
 ,ITEM_TYPE VARCHAR2 (45 BYTE)
 ,DESCRIPTION VARCHAR2 (2000 BYTE)
 ,COST_TOTAL NUMBER (8,2)
 ,TIME_MIN NUMBER
 ,LENGTH_MM NUMBER (8,2)
 ,WIDTH_MM NUMBER (8,2)
 ,THICKNESS_MM NUMBER (8,2)
 ,HEIGHT_MM NUMBER (8,2)
 ,WEIGHT_GR NUMBER (8,2)
 ,CURRENT_AMOUNT NUMBER
 ,PURCHASED_AMOUNT NUMBER
 );

CREATE OR REPLACE TRIGGER MWD.ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ITEMS for each row 
 Declare 
  rec MWD.ITEMS_JN%ROWTYPE; 
  blank MWD.ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.NAME := :NEW.NAME; 
      rec.LIST_PRICE := :NEW.LIST_PRICE; 
      rec.AVAILABILITY := :NEW.AVAILABILITY; 
      rec.SALE_STATUS := :NEW.SALE_STATUS; 
      rec.ITEM_TYPE := :NEW.ITEM_TYPE; 
      rec.DESCRIPTION := :NEW.DESCRIPTION; 
      rec.COST_TOTAL := :NEW.COST_TOTAL; 
      rec.TIME_MIN := :NEW.TIME_MIN; 
      rec.LENGTH_MM := :NEW.LENGTH_MM; 
      rec.WIDTH_MM := :NEW.WIDTH_MM; 
      rec.THICKNESS_MM := :NEW.THICKNESS_MM; 
      rec.HEIGHT_MM := :NEW.HEIGHT_MM; 
      rec.WEIGHT_GR := :NEW.WEIGHT_GR; 
      rec.CURRENT_AMOUNT := :NEW.CURRENT_AMOUNT; 
      rec.PURCHASED_AMOUNT := :NEW.PURCHASED_AMOUNT; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.NAME := :OLD.NAME; 
      rec.LIST_PRICE := :OLD.LIST_PRICE; 
      rec.AVAILABILITY := :OLD.AVAILABILITY; 
      rec.SALE_STATUS := :OLD.SALE_STATUS; 
      rec.ITEM_TYPE := :OLD.ITEM_TYPE; 
      rec.DESCRIPTION := :OLD.DESCRIPTION; 
      rec.COST_TOTAL := :OLD.COST_TOTAL; 
      rec.TIME_MIN := :OLD.TIME_MIN; 
      rec.LENGTH_MM := :OLD.LENGTH_MM; 
      rec.WIDTH_MM := :OLD.WIDTH_MM; 
      rec.THICKNESS_MM := :OLD.THICKNESS_MM; 
      rec.HEIGHT_MM := :OLD.HEIGHT_MM; 
      rec.WEIGHT_GR := :OLD.WEIGHT_GR; 
      rec.CURRENT_AMOUNT := :OLD.CURRENT_AMOUNT; 
      rec.PURCHASED_AMOUNT := :OLD.PURCHASED_AMOUNT; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.jewelry (
    created_item_id   NUMBER NOT NULL,
    jewelry_type      VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.jewelry_pk ON
    mwd.jewelry (
        created_item_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.jewelry
    ADD CONSTRAINT jewelry_pk PRIMARY KEY ( created_item_id )
        USING INDEX mwd.jewelry_pk;


CREATE TABLE MWD.JEWELRY_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CREATED_ITEM_ID NUMBER NOT NULL
 ,JEWELRY_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.JEWELRY_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.JEWELRY for each row 
 Declare 
  rec MWD.JEWELRY_JN%ROWTYPE; 
  blank MWD.JEWELRY_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CREATED_ITEM_ID := :NEW.CREATED_ITEM_ID; 
      rec.JEWELRY_TYPE := :NEW.JEWELRY_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CREATED_ITEM_ID := :OLD.CREATED_ITEM_ID; 
      rec.JEWELRY_TYPE := :OLD.JEWELRY_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.JEWELRY_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.kit_items (
    kit_item_id   NUMBER NOT NULL,
    kit_id        NUMBER NOT NULL,
    item_id       NUMBER NOT NULL,
    unit_price    NUMBER(8, 2) DEFAULT 0 NOT NULL,
    quantity      NUMBER(8) DEFAULT 1 NOT NULL
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.kit_items_pk ON
    mwd.kit_items (
        kit_item_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.kit_items_uk ON
    mwd.kit_items (
        kit_id
    ASC,
        item_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.kit_items
    ADD CONSTRAINT kit_items_pk PRIMARY KEY ( kit_item_id )
        USING INDEX mwd.kit_items_pk;

ALTER TABLE mwd.kit_items
    ADD CONSTRAINT kit_items_uk UNIQUE ( kit_id,
                                         item_id )
        USING INDEX mwd.kit_items_uk;

ALTER TABLE mwd.kit_items
    ADD CONSTRAINT kit_items_uk2 UNIQUE ( kit_id )
        USING INDEX TABLESPACE bp NOLOGGING;


CREATE TABLE MWD.KIT_ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,KIT_ITEM_ID NUMBER NOT NULL
 ,KIT_ID NUMBER NOT NULL
 ,ITEM_ID NUMBER NOT NULL
 ,UNIT_PRICE NUMBER (8,2) NOT NULL
 ,QUANTITY NUMBER (8) NOT NULL
 );

CREATE OR REPLACE TRIGGER MWD.KIT_ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.KIT_ITEMS for each row 
 Declare 
  rec MWD.KIT_ITEMS_JN%ROWTYPE; 
  blank MWD.KIT_ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.KIT_ITEM_ID := :NEW.KIT_ITEM_ID; 
      rec.KIT_ID := :NEW.KIT_ID; 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.UNIT_PRICE := :NEW.UNIT_PRICE; 
      rec.QUANTITY := :NEW.QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.KIT_ITEM_ID := :OLD.KIT_ITEM_ID; 
      rec.KIT_ID := :OLD.KIT_ID; 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.UNIT_PRICE := :OLD.UNIT_PRICE; 
      rec.QUANTITY := :OLD.QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.KIT_ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.kits (
    kit_id         NUMBER NOT NULL,
    name           VARCHAR2(30 BYTE),
    list_price     NUMBER(8, 2) DEFAULT 0 NOT NULL,
    availability   VARCHAR2(30 BYTE) DEFAULT 'IN_STOCK',
    sale_status    VARCHAR2(30 BYTE) DEFAULT 'NONE'
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.kits_pk ON
    mwd.kits (
        kit_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.kits_uk ON
    mwd.kits (
        name
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.kits
    ADD CONSTRAINT kits_pk PRIMARY KEY ( kit_id )
        USING INDEX mwd.kits_pk;

ALTER TABLE mwd.kits
    ADD CONSTRAINT kits_uk UNIQUE ( name )
        USING INDEX mwd.kits_uk;


CREATE TABLE MWD.KITS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,KIT_ID NUMBER NOT NULL
 ,NAME VARCHAR2 (30 BYTE)
 ,LIST_PRICE NUMBER (8,2) NOT NULL
 ,AVAILABILITY VARCHAR2 (30 BYTE)
 ,SALE_STATUS VARCHAR2 (30 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.KITS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.KITS for each row 
 Declare 
  rec MWD.KITS_JN%ROWTYPE; 
  blank MWD.KITS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.KIT_ID := :NEW.KIT_ID; 
      rec.NAME := :NEW.NAME; 
      rec.LIST_PRICE := :NEW.LIST_PRICE; 
      rec.AVAILABILITY := :NEW.AVAILABILITY; 
      rec.SALE_STATUS := :NEW.SALE_STATUS; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.KIT_ID := :OLD.KIT_ID; 
      rec.NAME := :OLD.NAME; 
      rec.LIST_PRICE := :OLD.LIST_PRICE; 
      rec.AVAILABILITY := :OLD.AVAILABILITY; 
      rec.SALE_STATUS := :OLD.SALE_STATUS; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.KITS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.lace (
    lace_id     NUMBER NOT NULL,
    lace_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.lace_pk ON
    mwd.lace (
        lace_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.lace
    ADD CONSTRAINT lace_pk PRIMARY KEY ( lace_id )
        USING INDEX mwd.lace_pk;


CREATE TABLE MWD.LACE_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,LACE_ID NUMBER NOT NULL
 ,LACE_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.LACE_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.LACE for each row 
 Declare 
  rec MWD.LACE_JN%ROWTYPE; 
  blank MWD.LACE_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.LACE_ID := :NEW.LACE_ID; 
      rec.LACE_TYPE := :NEW.LACE_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.LACE_ID := :OLD.LACE_ID; 
      rec.LACE_TYPE := :OLD.LACE_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.LACE_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.legal_persons (
    person_id    NUMBER NOT NULL,
    legal_name   VARCHAR2(30 BYTE) NOT NULL,
    website      VARCHAR2(2000 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.legal_persons_ix ON
    mwd.legal_persons (
        legal_name
    ASC )
        TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.legal_persons_pk ON
    mwd.legal_persons (
        person_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.legal_persons
    ADD CONSTRAINT legal_persons_pk PRIMARY KEY ( person_id )
        USING INDEX mwd.legal_persons_pk;


CREATE TABLE MWD.LEGAL_PERSONS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,PERSON_ID NUMBER NOT NULL
 ,LEGAL_NAME VARCHAR2 (30 BYTE) NOT NULL
 ,WEBSITE VARCHAR2 (2000 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.LEGAL_PERSONS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.LEGAL_PERSONS for each row 
 Declare 
  rec MWD.LEGAL_PERSONS_JN%ROWTYPE; 
  blank MWD.LEGAL_PERSONS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.PERSON_ID := :NEW.PERSON_ID; 
      rec.LEGAL_NAME := :NEW.LEGAL_NAME; 
      rec.WEBSITE := :NEW.WEBSITE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.PERSON_ID := :OLD.PERSON_ID; 
      rec.LEGAL_NAME := :OLD.LEGAL_NAME; 
      rec.WEBSITE := :OLD.WEBSITE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.LEGAL_PERSONS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.location_addresses (
    location_address_id   NUMBER NOT NULL,
    location_id           NUMBER NOT NULL,
    street                VARCHAR2(255 BYTE),
    nr                    NUMBER,
    nr_addition           VARCHAR2(5 BYTE),
    city                  VARCHAR2(50 BYTE),
    country               VARCHAR2(50 BYTE),
    postal_code           VARCHAR2(12 BYTE),
    latitude              NUMBER(9, 6),
    longitude             NUMBER(9, 6),
    is_main               CHAR(1 BYTE),
    is_active             CHAR(1 BYTE),
    address_type          VARCHAR2(30 BYTE)
)
TABLESPACE bp LOGGING;

CREATE INDEX mwd.location_addresses_ix ON
    mwd.location_addresses (
        city
    ASC )
        TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.location_addresses_pk ON
    mwd.location_addresses (
        location_address_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.location_addresses
    ADD CONSTRAINT location_addresses_pk PRIMARY KEY ( location_address_id )
        USING INDEX mwd.location_addresses_pk;


CREATE TABLE MWD.LOCATION_ADDRESSES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,LOCATION_ADDRESS_ID NUMBER NOT NULL
 ,LOCATION_ID NUMBER NOT NULL
 ,STREET VARCHAR2 (255 BYTE)
 ,NR NUMBER
 ,NR_ADDITION VARCHAR2 (5 BYTE)
 ,CITY VARCHAR2 (50 BYTE)
 ,COUNTRY VARCHAR2 (50 BYTE)
 ,POSTAL_CODE VARCHAR2 (12 BYTE)
 ,LATITUDE NUMBER (9,6)
 ,LONGITUDE NUMBER (9,6)
 ,IS_MAIN CHAR (1 BYTE)
 ,IS_ACTIVE CHAR (1 BYTE)
 ,ADDRESS_TYPE VARCHAR2 (30 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.LOCATION_ADDRESSES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.LOCATION_ADDRESSES for each row 
 Declare 
  rec MWD.LOCATION_ADDRESSES_JN%ROWTYPE; 
  blank MWD.LOCATION_ADDRESSES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.LOCATION_ADDRESS_ID := :NEW.LOCATION_ADDRESS_ID; 
      rec.LOCATION_ID := :NEW.LOCATION_ID; 
      rec.STREET := :NEW.STREET; 
      rec.NR := :NEW.NR; 
      rec.NR_ADDITION := :NEW.NR_ADDITION; 
      rec.CITY := :NEW.CITY; 
      rec.COUNTRY := :NEW.COUNTRY; 
      rec.POSTAL_CODE := :NEW.POSTAL_CODE; 
      rec.LATITUDE := :NEW.LATITUDE; 
      rec.LONGITUDE := :NEW.LONGITUDE; 
      rec.IS_MAIN := :NEW.IS_MAIN; 
      rec.IS_ACTIVE := :NEW.IS_ACTIVE; 
      rec.ADDRESS_TYPE := :NEW.ADDRESS_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.LOCATION_ADDRESS_ID := :OLD.LOCATION_ADDRESS_ID; 
      rec.LOCATION_ID := :OLD.LOCATION_ID; 
      rec.STREET := :OLD.STREET; 
      rec.NR := :OLD.NR; 
      rec.NR_ADDITION := :OLD.NR_ADDITION; 
      rec.CITY := :OLD.CITY; 
      rec.COUNTRY := :OLD.COUNTRY; 
      rec.POSTAL_CODE := :OLD.POSTAL_CODE; 
      rec.LATITUDE := :OLD.LATITUDE; 
      rec.LONGITUDE := :OLD.LONGITUDE; 
      rec.IS_MAIN := :OLD.IS_MAIN; 
      rec.IS_ACTIVE := :OLD.IS_ACTIVE; 
      rec.ADDRESS_TYPE := :OLD.ADDRESS_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.LOCATION_ADDRESSES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.locations (
    location_id   NUMBER NOT NULL
,	person_id 	  NUMBER NOT NULL
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.locations_pk ON
    mwd.locations (
        location_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.locations
    ADD CONSTRAINT locations_pk PRIMARY KEY ( location_id )
        USING INDEX mwd.locations_pk;


CREATE TABLE MWD.LOCATIONS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,LOCATION_ID NUMBER NOT NULL
 ,PERSON_ID NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER MWD.LOCATIONS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.LOCATIONS for each row 
 Declare 
  rec MWD.LOCATIONS_JN%ROWTYPE; 
  blank MWD.LOCATIONS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.LOCATION_ID := :NEW.LOCATION_ID; 
	  rec.PERSON_ID := :NEW.PERSON_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.LOCATION_ID := :OLD.LOCATION_ID; 
	  rec.PERSON_ID := :OLD.PERSON_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.LOCATIONS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.materials (
    abbreviation              VARCHAR2(45 BYTE) NOT NULL,
    base_material             VARCHAR2(45 BYTE),
    processing                VARCHAR2(45 BYTE),
    processing_material       VARCHAR2(45 BYTE),
    allergens_excluded        VARCHAR2(45 BYTE),
    base_materials_included   VARCHAR2(2000 BYTE),
    parent_material           VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE INDEX mwd.materials_pk ON
    mwd.materials (
        abbreviation
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.materials
    ADD CONSTRAINT materials_pk PRIMARY KEY ( abbreviation )
        USING INDEX mwd.materials_pk;


CREATE TABLE MWD.MATERIALS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ABBREVIATION VARCHAR2 (45 BYTE) NOT NULL
 ,BASE_MATERIAL VARCHAR2 (45 BYTE)
 ,PROCESSING VARCHAR2 (45 BYTE)
 ,PROCESSING_MATERIAL VARCHAR2 (45 BYTE)
 ,ALLERGENS_EXCLUDED VARCHAR2 (45 BYTE)
 ,BASE_MATERIALS_INCLUDED VARCHAR2 (2000 BYTE)
 ,PARENT_MATERIAL VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.MATERIALS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.MATERIALS for each row 
 Declare 
  rec MWD.MATERIALS_JN%ROWTYPE; 
  blank MWD.MATERIALS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ABBREVIATION := :NEW.ABBREVIATION; 
      rec.BASE_MATERIAL := :NEW.BASE_MATERIAL; 
      rec.PROCESSING := :NEW.PROCESSING; 
      rec.PROCESSING_MATERIAL := :NEW.PROCESSING_MATERIAL; 
      rec.ALLERGENS_EXCLUDED := :NEW.ALLERGENS_EXCLUDED; 
      rec.BASE_MATERIALS_INCLUDED := :NEW.BASE_MATERIALS_INCLUDED; 
      rec.PARENT_MATERIAL := :NEW.PARENT_MATERIAL; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ABBREVIATION := :OLD.ABBREVIATION; 
      rec.BASE_MATERIAL := :OLD.BASE_MATERIAL; 
      rec.PROCESSING := :OLD.PROCESSING; 
      rec.PROCESSING_MATERIAL := :OLD.PROCESSING_MATERIAL; 
      rec.ALLERGENS_EXCLUDED := :OLD.ALLERGENS_EXCLUDED; 
      rec.BASE_MATERIALS_INCLUDED := :OLD.BASE_MATERIALS_INCLUDED; 
      rec.PARENT_MATERIAL := :OLD.PARENT_MATERIAL; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.MATERIALS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.natural_persons (
    person_id    NUMBER NOT NULL,
    first_name   VARCHAR2(30 BYTE) NOT NULL,
    last_name    VARCHAR2(30 BYTE) NOT NULL
)
TABLESPACE bp LOGGING;

CREATE INDEX mwd.natural_persons_ix ON
    mwd.natural_persons (
        last_name
    ASC,
        first_name
    ASC )
        TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.natural_persons_pk ON
    mwd.natural_persons (
        person_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.natural_persons
    ADD CONSTRAINT natural_persons_pk PRIMARY KEY ( person_id )
        USING INDEX mwd.natural_persons_pk;


CREATE TABLE MWD.NATURAL_PERSONS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,PERSON_ID NUMBER NOT NULL
 ,FIRST_NAME VARCHAR2 (30 BYTE) NOT NULL
 ,LAST_NAME VARCHAR2 (30 BYTE) NOT NULL
 );

CREATE OR REPLACE TRIGGER MWD.NATURAL_PERSONS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.NATURAL_PERSONS for each row 
 Declare 
  rec MWD.NATURAL_PERSONS_JN%ROWTYPE; 
  blank MWD.NATURAL_PERSONS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.PERSON_ID := :NEW.PERSON_ID; 
      rec.FIRST_NAME := :NEW.FIRST_NAME; 
      rec.LAST_NAME := :NEW.LAST_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.PERSON_ID := :OLD.PERSON_ID; 
      rec.FIRST_NAME := :OLD.FIRST_NAME; 
      rec.LAST_NAME := :OLD.LAST_NAME; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.NATURAL_PERSONS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.order_items (
    order_item_id    NUMBER(3) NOT NULL,
    order_id         NUMBER NOT NULL,
    item_id          NUMBER NOT NULL,
    unit_price       NUMBER(8, 2) DEFAULT 0 NOT NULL,
    quantity         NUMBER(8) DEFAULT 1 NOT NULL,
    item_status      VARCHAR2(30 BYTE) DEFAULT 'NOT_MADE' NOT NULL,
    order_item_url   VARCHAR2(2000 BYTE)
)
TABLESPACE bp NOLOGGING;

COMMENT ON COLUMN mwd.order_items.item_status IS
    'ENUM(''TO_DELIVER'', ''DELIVERED'', ''CANCELLED''), DEFAULT ''TO_DELIVER''';

CREATE UNIQUE INDEX mwd.order_items_pk ON
    mwd.order_items (
        order_item_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.order_items_uk ON
    mwd.order_items (
        order_id
    ASC,
        item_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.order_items_uk2 ON
    mwd.order_items (
        order_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.order_items_uk3 ON
    mwd.order_items (
        order_id
    ASC,
        order_item_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.order_items
    ADD CONSTRAINT order_items_pk PRIMARY KEY ( order_item_id )
        USING INDEX mwd.order_items_pk;

ALTER TABLE mwd.order_items
    ADD CONSTRAINT order_items_uk UNIQUE ( order_id,
                                           item_id )
        USING INDEX mwd.order_items_uk;

ALTER TABLE mwd.order_items
    ADD CONSTRAINT order_items_uk2 UNIQUE ( order_id,
                                            order_item_id )
        USING INDEX mwd.order_items_uk3;


CREATE TABLE MWD.ORDER_ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ORDER_ITEM_ID NUMBER (3) NOT NULL
 ,ORDER_ID NUMBER NOT NULL
 ,ITEM_ID NUMBER NOT NULL
 ,UNIT_PRICE NUMBER (8,2) NOT NULL
 ,QUANTITY NUMBER (8) NOT NULL
 ,ITEM_STATUS VARCHAR2 (30 BYTE) NOT NULL
 ,ORDER_ITEM_URL VARCHAR2 (2000 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.ORDER_ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ORDER_ITEMS for each row 
 Declare 
  rec MWD.ORDER_ITEMS_JN%ROWTYPE; 
  blank MWD.ORDER_ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ORDER_ITEM_ID := :NEW.ORDER_ITEM_ID; 
      rec.ORDER_ID := :NEW.ORDER_ID; 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.UNIT_PRICE := :NEW.UNIT_PRICE; 
      rec.QUANTITY := :NEW.QUANTITY; 
      rec.ITEM_STATUS := :NEW.ITEM_STATUS; 
      rec.ORDER_ITEM_URL := :NEW.ORDER_ITEM_URL; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ORDER_ITEM_ID := :OLD.ORDER_ITEM_ID; 
      rec.ORDER_ID := :OLD.ORDER_ID; 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.UNIT_PRICE := :OLD.UNIT_PRICE; 
      rec.QUANTITY := :OLD.QUANTITY; 
      rec.ITEM_STATUS := :OLD.ITEM_STATUS; 
      rec.ORDER_ITEM_URL := :OLD.ORDER_ITEM_URL; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ORDER_ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.orders (
    order_id              NUMBER NOT NULL,
    location_address_id   NUMBER,
    person_id             NUMBER,
    order_type            VARCHAR2(30 BYTE) DEFAULT 'SALE' NOT NULL,
    order_date            TIMESTAMP WITH LOCAL TIME ZONE,
    shipping              NUMBER(10, 2),
    is_online             CHAR(1 BYTE)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.orders_pk ON
    mwd.orders (
        order_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.orders
    ADD CONSTRAINT orders_pk PRIMARY KEY ( order_id )
        USING INDEX mwd.orders_pk;


CREATE TABLE MWD.ORDERS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ORDER_ID NUMBER NOT NULL
 ,LOCATION_ADDRESS_ID NUMBER
 ,PERSON_ID NUMBER
 ,ORDER_TYPE VARCHAR2 (30 BYTE) NOT NULL
 ,ORDER_DATE TIMESTAMP WITH LOCAL TIME ZONE
 ,SHIPPING NUMBER (10,2)
 ,IS_ONLINE CHAR (1 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.ORDERS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ORDERS for each row 
 Declare 
  rec MWD.ORDERS_JN%ROWTYPE; 
  blank MWD.ORDERS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ORDER_ID := :NEW.ORDER_ID; 
      rec.LOCATION_ADDRESS_ID := :NEW.LOCATION_ADDRESS_ID; 
      rec.PERSON_ID := :NEW.PERSON_ID; 
      rec.ORDER_TYPE := :NEW.ORDER_TYPE; 
      rec.ORDER_DATE := :NEW.ORDER_DATE; 
      rec.SHIPPING := :NEW.SHIPPING; 
      rec.IS_ONLINE := :NEW.IS_ONLINE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ORDER_ID := :OLD.ORDER_ID; 
      rec.LOCATION_ADDRESS_ID := :OLD.LOCATION_ADDRESS_ID; 
      rec.PERSON_ID := :OLD.PERSON_ID; 
      rec.ORDER_TYPE := :OLD.ORDER_TYPE; 
      rec.ORDER_DATE := :OLD.ORDER_DATE; 
      rec.SHIPPING := :OLD.SHIPPING; 
      rec.IS_ONLINE := :OLD.IS_ONLINE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ORDERS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.ornaments (
    created_item_id   NUMBER NOT NULL,
    ornament_type     VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.ornaments_pk ON
    mwd.ornaments (
        created_item_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.ornaments
    ADD CONSTRAINT ornaments_pk PRIMARY KEY ( created_item_id )
        USING INDEX mwd.ornaments_pk;


CREATE TABLE MWD.ORNAMENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,CREATED_ITEM_ID NUMBER NOT NULL
 ,ORNAMENT_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.ORNAMENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.ORNAMENTS for each row 
 Declare 
  rec MWD.ORNAMENTS_JN%ROWTYPE; 
  blank MWD.ORNAMENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.CREATED_ITEM_ID := :NEW.CREATED_ITEM_ID; 
      rec.ORNAMENT_TYPE := :NEW.ORNAMENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.CREATED_ITEM_ID := :OLD.CREATED_ITEM_ID; 
      rec.ORNAMENT_TYPE := :OLD.ORNAMENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.ORNAMENTS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.other_ingredients (
    other_ingredient_id     NUMBER NOT NULL,
    other_ingredient_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.other_ingredients_pk ON
    mwd.other_ingredients (
        other_ingredient_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.other_ingredients
    ADD CONSTRAINT other_ingredients_pk PRIMARY KEY ( other_ingredient_id )
        USING INDEX mwd.other_ingredients_pk;


CREATE TABLE MWD.OTHER_INGREDIENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,OTHER_INGREDIENT_ID NUMBER NOT NULL
 ,OTHER_INGREDIENT_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.OTHER_INGREDIENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.OTHER_INGREDIENTS for each row 
 Declare 
  rec MWD.OTHER_INGREDIENTS_JN%ROWTYPE; 
  blank MWD.OTHER_INGREDIENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.OTHER_INGREDIENT_ID := :NEW.OTHER_INGREDIENT_ID; 
      rec.OTHER_INGREDIENT_TYPE := :NEW.OTHER_INGREDIENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.OTHER_INGREDIENT_ID := :OLD.OTHER_INGREDIENT_ID; 
      rec.OTHER_INGREDIENT_TYPE := :OLD.OTHER_INGREDIENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.OTHER_INGREDIENTS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.other_items (
    other_item_id     NUMBER NOT NULL,
    other_item_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.other_items_pk ON
    mwd.other_items (
        other_item_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.other_items
    ADD CONSTRAINT other_items_pk PRIMARY KEY ( other_item_id )
        USING INDEX mwd.other_items_pk;


CREATE TABLE MWD.OTHER_ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,OTHER_ITEM_ID NUMBER NOT NULL
 ,OTHER_ITEM_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.OTHER_ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.OTHER_ITEMS for each row 
 Declare 
  rec MWD.OTHER_ITEMS_JN%ROWTYPE; 
  blank MWD.OTHER_ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.OTHER_ITEM_ID := :NEW.OTHER_ITEM_ID; 
      rec.OTHER_ITEM_TYPE := :NEW.OTHER_ITEM_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.OTHER_ITEM_ID := :OLD.OTHER_ITEM_ID; 
      rec.OTHER_ITEM_TYPE := :OLD.OTHER_ITEM_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.OTHER_ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.persons (
    person_id       NUMBER NOT NULL,
    email           VARCHAR2(30 BYTE),
    phone_fixed     VARCHAR2(30 BYTE),
    is_competitor   CHAR(1 BYTE) NOT NULL,
    person_type     VARCHAR2(30 BYTE)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.persons_pk ON
    mwd.persons (
        person_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.persons
    ADD CONSTRAINT persons_pk PRIMARY KEY ( person_id )
        USING INDEX mwd.persons_pk;


CREATE TABLE MWD.PERSONS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,PERSON_ID NUMBER NOT NULL
 ,EMAIL VARCHAR2 (30 BYTE)
 ,PHONE_FIXED VARCHAR2 (30 BYTE)
 ,IS_COMPETITOR CHAR (1 BYTE) NOT NULL
 ,PERSON_TYPE VARCHAR2 (30 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.PERSONS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.PERSONS for each row 
 Declare 
  rec MWD.PERSONS_JN%ROWTYPE; 
  blank MWD.PERSONS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.PERSON_ID := :NEW.PERSON_ID; 
      rec.EMAIL := :NEW.EMAIL; 
      rec.PHONE_FIXED := :NEW.PHONE_FIXED; 
      rec.IS_COMPETITOR := :NEW.IS_COMPETITOR; 
      rec.PERSON_TYPE := :NEW.PERSON_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.PERSON_ID := :OLD.PERSON_ID; 
      rec.EMAIL := :OLD.EMAIL; 
      rec.PHONE_FIXED := :OLD.PHONE_FIXED; 
      rec.IS_COMPETITOR := :OLD.IS_COMPETITOR; 
      rec.PERSON_TYPE := :OLD.PERSON_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.PERSONS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.purchases (
    order_id       NUMBER NOT NULL,
    order_status   VARCHAR2(45 BYTE) NOT NULL,
    tax_returned   CHAR(1 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.purchases_pk ON
    mwd.purchases (
        order_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.purchases
    ADD CONSTRAINT purchases_pk PRIMARY KEY ( order_id )
        USING INDEX mwd.purchases_pk;


CREATE TABLE MWD.PURCHASES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ORDER_ID NUMBER NOT NULL
 ,ORDER_STATUS VARCHAR2 (45 BYTE) NOT NULL
 ,TAX_RETURNED CHAR (1 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.PURCHASES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.PURCHASES for each row 
 Declare 
  rec MWD.PURCHASES_JN%ROWTYPE; 
  blank MWD.PURCHASES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ORDER_ID := :NEW.ORDER_ID; 
      rec.ORDER_STATUS := :NEW.ORDER_STATUS; 
      rec.TAX_RETURNED := :NEW.TAX_RETURNED; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ORDER_ID := :OLD.ORDER_ID; 
      rec.ORDER_STATUS := :OLD.ORDER_STATUS; 
      rec.TAX_RETURNED := :OLD.TAX_RETURNED; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.PURCHASES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.raw_ingredients (
    raw_ingredient_id     NUMBER NOT NULL,
    raw_ingredient_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.raw_ingredients_pk ON
    mwd.raw_ingredients (
        raw_ingredient_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.raw_ingredients
    ADD CONSTRAINT raw_ingredients_pk PRIMARY KEY ( raw_ingredient_id )
        USING INDEX mwd.raw_ingredients_pk;


CREATE TABLE MWD.RAW_INGREDIENTS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,RAW_INGREDIENT_ID NUMBER NOT NULL
 ,RAW_INGREDIENT_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.RAW_INGREDIENTS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.RAW_INGREDIENTS for each row 
 Declare 
  rec MWD.RAW_INGREDIENTS_JN%ROWTYPE; 
  blank MWD.RAW_INGREDIENTS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.RAW_INGREDIENT_ID := :NEW.RAW_INGREDIENT_ID; 
      rec.RAW_INGREDIENT_TYPE := :NEW.RAW_INGREDIENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.RAW_INGREDIENT_ID := :OLD.RAW_INGREDIENT_ID; 
      rec.RAW_INGREDIENT_TYPE := :OLD.RAW_INGREDIENT_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.RAW_INGREDIENTS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.rings (
    ring_id     NUMBER NOT NULL,
    ring_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.rings_pk ON
    mwd.rings (
        ring_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.rings
    ADD CONSTRAINT rings_pk PRIMARY KEY ( ring_id )
        USING INDEX mwd.rings_pk;


CREATE TABLE MWD.RINGS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,RING_ID NUMBER NOT NULL
 ,RING_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.RINGS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.RINGS for each row 
 Declare 
  rec MWD.RINGS_JN%ROWTYPE; 
  blank MWD.RINGS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.RING_ID := :NEW.RING_ID; 
      rec.RING_TYPE := :NEW.RING_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.RING_ID := :OLD.RING_ID; 
      rec.RING_TYPE := :OLD.RING_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.RINGS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.sales (
    order_id          NUMBER NOT NULL,
    invoice_year      VARCHAR2(4 BYTE) NOT NULL,
    invoice_quarter   VARCHAR2(3 BYTE) NOT NULL,
    invoice_number    VARCHAR2(45 BYTE) NOT NULL,
    order_status      VARCHAR2(45 BYTE) NOT NULL,
    complete_date     TIMESTAMP WITH LOCAL TIME ZONE
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.sales_ix ON
    mwd.sales (
        invoice_year
    ASC,
        invoice_quarter
    ASC,
        invoice_number
    ASC )
        TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.sales_pk ON
    mwd.sales (
        order_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.sales
    ADD CONSTRAINT sales_pk PRIMARY KEY ( order_id )
        USING INDEX mwd.sales_pk;


CREATE TABLE MWD.SALES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,ORDER_ID NUMBER NOT NULL
 ,INVOICE_YEAR VARCHAR2 (4 BYTE) NOT NULL
 ,INVOICE_QUARTER VARCHAR2 (3 BYTE) NOT NULL
 ,INVOICE_NUMBER VARCHAR2 (45 BYTE) NOT NULL
 ,ORDER_STATUS VARCHAR2 (45 BYTE) NOT NULL
 ,COMPLETE_DATE TIMESTAMP WITH LOCAL TIME ZONE
 );

CREATE OR REPLACE TRIGGER MWD.SALES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.SALES for each row 
 Declare 
  rec MWD.SALES_JN%ROWTYPE; 
  blank MWD.SALES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.ORDER_ID := :NEW.ORDER_ID; 
      rec.INVOICE_YEAR := :NEW.INVOICE_YEAR; 
      rec.INVOICE_QUARTER := :NEW.INVOICE_QUARTER; 
      rec.INVOICE_NUMBER := :NEW.INVOICE_NUMBER; 
      rec.ORDER_STATUS := :NEW.ORDER_STATUS; 
      rec.COMPLETE_DATE := :NEW.COMPLETE_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.ORDER_ID := :OLD.ORDER_ID; 
      rec.INVOICE_YEAR := :OLD.INVOICE_YEAR; 
      rec.INVOICE_QUARTER := :OLD.INVOICE_QUARTER; 
      rec.INVOICE_NUMBER := :OLD.INVOICE_NUMBER; 
      rec.ORDER_STATUS := :OLD.ORDER_STATUS; 
      rec.COMPLETE_DATE := :OLD.COMPLETE_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.SALES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.scales (
    scale_id     NUMBER NOT NULL,
    scale_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.scales_pk ON
    mwd.scales (
        scale_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.scales
    ADD CONSTRAINT scales_pk PRIMARY KEY ( scale_id )
        USING INDEX mwd.scales_pk;


CREATE TABLE MWD.SCALES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,SCALE_ID NUMBER NOT NULL
 ,SCALE_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.SCALES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.SCALES for each row 
 Declare 
  rec MWD.SCALES_JN%ROWTYPE; 
  blank MWD.SCALES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.SCALE_ID := :NEW.SCALE_ID; 
      rec.SCALE_TYPE := :NEW.SCALE_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.SCALE_ID := :OLD.SCALE_ID; 
      rec.SCALE_TYPE := :OLD.SCALE_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.SCALES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.set_items (
    set_item_id       NUMBER NOT NULL,
    set_id            NUMBER NOT NULL,
    created_item_id   NUMBER NOT NULL,
    unit_price        NUMBER(8, 2) DEFAULT 0 NOT NULL,
    quantity          NUMBER(8) DEFAULT 1 NOT NULL
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.set_items_pk ON
    mwd.set_items (
        set_item_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.set_items_uk ON
    mwd.set_items (
        set_id
    ASC,
        created_item_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.set_items
    ADD CONSTRAINT set_items_pk PRIMARY KEY ( set_item_id )
        USING INDEX mwd.set_items_pk;

ALTER TABLE mwd.set_items
    ADD CONSTRAINT set_items_uk UNIQUE ( set_id,
                                         created_item_id )
        USING INDEX mwd.set_items_uk;


CREATE TABLE MWD.SET_ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,SET_ITEM_ID NUMBER NOT NULL
 ,SET_ID NUMBER NOT NULL
 ,CREATED_ITEM_ID NUMBER NOT NULL
 ,UNIT_PRICE NUMBER (8,2) NOT NULL
 ,QUANTITY NUMBER (8) NOT NULL
 );

CREATE OR REPLACE TRIGGER MWD.SET_ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.SET_ITEMS for each row 
 Declare 
  rec MWD.SET_ITEMS_JN%ROWTYPE; 
  blank MWD.SET_ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.SET_ITEM_ID := :NEW.SET_ITEM_ID; 
      rec.SET_ID := :NEW.SET_ID; 
      rec.CREATED_ITEM_ID := :NEW.CREATED_ITEM_ID; 
      rec.UNIT_PRICE := :NEW.UNIT_PRICE; 
      rec.QUANTITY := :NEW.QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.SET_ITEM_ID := :OLD.SET_ITEM_ID; 
      rec.SET_ID := :OLD.SET_ID; 
      rec.CREATED_ITEM_ID := :OLD.CREATED_ITEM_ID; 
      rec.UNIT_PRICE := :OLD.UNIT_PRICE; 
      rec.QUANTITY := :OLD.QUANTITY; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.SET_ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.sets (
    set_id         NUMBER NOT NULL,
    name           VARCHAR2(45 BYTE),
    list_price     NUMBER(8, 2) DEFAULT 0 NOT NULL,
    availability   VARCHAR2(45 BYTE) DEFAULT 'IN_STOCK',
    sale_status    VARCHAR2(45 BYTE) DEFAULT 'NONE'
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.sets_pk ON
    mwd.sets (
        set_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.sets_uk ON
    mwd.sets (
        name
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.sets
    ADD CONSTRAINT sets_pk PRIMARY KEY ( set_id )
        USING INDEX mwd.sets_pk;

ALTER TABLE mwd.sets
    ADD CONSTRAINT sets_uk UNIQUE ( name )
        USING INDEX mwd.sets_uk;


CREATE TABLE MWD.SETS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,SET_ID NUMBER NOT NULL
 ,NAME VARCHAR2 (45 BYTE)
 ,LIST_PRICE NUMBER (8,2) NOT NULL
 ,AVAILABILITY VARCHAR2 (45 BYTE)
 ,SALE_STATUS VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.SETS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.SETS for each row 
 Declare 
  rec MWD.SETS_JN%ROWTYPE; 
  blank MWD.SETS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.SET_ID := :NEW.SET_ID; 
      rec.NAME := :NEW.NAME; 
      rec.LIST_PRICE := :NEW.LIST_PRICE; 
      rec.AVAILABILITY := :NEW.AVAILABILITY; 
      rec.SALE_STATUS := :NEW.SALE_STATUS; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.SET_ID := :OLD.SET_ID; 
      rec.NAME := :OLD.NAME; 
      rec.LIST_PRICE := :OLD.LIST_PRICE; 
      rec.AVAILABILITY := :OLD.AVAILABILITY; 
      rec.SALE_STATUS := :OLD.SALE_STATUS; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.SETS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.standard_wire_gauges (
    swg_id          NUMBER NOT NULL,
    swg             VARCHAR2(30 BYTE),
    inch_diameter   NUMBER(10, 4),
    diameter_mm     NUMBER(10, 4)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.standard_wire_gauges_pk ON
    mwd.standard_wire_gauges (
        swg_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.standard_wire_gauges_uk ON
    mwd.standard_wire_gauges (
        swg
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.standard_wire_gauge
    ADD CONSTRAINT standard_wire_gauges_pk PRIMARY KEY ( swg_id )
        USING INDEX mwd.standard_wire_gauges_pk;

ALTER TABLE mwd.standard_wire_gauge
    ADD CONSTRAINT standard_wire_gauges_uk UNIQUE ( swg )
        USING INDEX mwd.standard_wire_gauges_uk;


CREATE TABLE MWD.STANDARD_WIRE_GAUGES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,SWG_ID NUMBER NOT NULL
 ,SWG VARCHAR2 (30 BYTE)
 ,INCH_DIAMETER NUMBER (10,4)
 ,DIAMETER_MM NUMBER (10,4)
 );

CREATE OR REPLACE TRIGGER MWD.STANDARD_WIRE_GAUGES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.STANDARD_WIRE_GAUGES for each row 
 Declare 
  rec MWD.STANDARD_WIRE_GAUGES_JN%ROWTYPE; 
  blank MWD.STANDARD_WIRE_GAUGES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.SWG_ID := :NEW.SWG_ID; 
      rec.SWG := :NEW.SWG; 
      rec.INCH_DIAMETER := :NEW.INCH_DIAMETER; 
      rec.DIAMETER_MM := :NEW.DIAMETER_MM; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.SWG_ID := :OLD.SWG_ID; 
      rec.SWG := :OLD.SWG; 
      rec.INCH_DIAMETER := :OLD.INCH_DIAMETER; 
      rec.DIAMETER_MM := :OLD.DIAMETER_MM; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.STANDARD_WIRE_GAUGES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.store_items (
    store_item_id     NUMBER NOT NULL,
    store_id          NUMBER NOT NULL,
    item_id           NUMBER NOT NULL,
    unit_price        NUMBER(8, 2) DEFAULT 0 NOT NULL,
    sale_start_date   DATE,
    discount_pct      NUMBER(4, 2),
    sale_end_date     DATE
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.store_items_pk ON
    mwd.store_items (
        store_item_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.store_items
    ADD CONSTRAINT store_items_pk PRIMARY KEY ( store_item_id )
        USING INDEX mwd.store_items_pk;

ALTER TABLE mwd.store_items ADD CONSTRAINT store_items_uk UNIQUE ( store_id,
                                                                   item_id );


CREATE TABLE MWD.STORE_ITEMS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,STORE_ITEM_ID NUMBER NOT NULL
 ,STORE_ID NUMBER NOT NULL
 ,ITEM_ID NUMBER NOT NULL
 ,UNIT_PRICE NUMBER (8,2) NOT NULL
 ,SALE_START_DATE DATE
 ,DISCOUNT_PCT NUMBER (4,2)
 ,SALE_END_DATE DATE
 );

CREATE OR REPLACE TRIGGER MWD.STORE_ITEMS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.STORE_ITEMS for each row 
 Declare 
  rec MWD.STORE_ITEMS_JN%ROWTYPE; 
  blank MWD.STORE_ITEMS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.STORE_ITEM_ID := :NEW.STORE_ITEM_ID; 
      rec.STORE_ID := :NEW.STORE_ID; 
      rec.ITEM_ID := :NEW.ITEM_ID; 
      rec.UNIT_PRICE := :NEW.UNIT_PRICE; 
      rec.SALE_START_DATE := :NEW.SALE_START_DATE; 
      rec.DISCOUNT_PCT := :NEW.DISCOUNT_PCT; 
      rec.SALE_END_DATE := :NEW.SALE_END_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.STORE_ITEM_ID := :OLD.STORE_ITEM_ID; 
      rec.STORE_ID := :OLD.STORE_ID; 
      rec.ITEM_ID := :OLD.ITEM_ID; 
      rec.UNIT_PRICE := :OLD.UNIT_PRICE; 
      rec.SALE_START_DATE := :OLD.SALE_START_DATE; 
      rec.DISCOUNT_PCT := :OLD.DISCOUNT_PCT; 
      rec.SALE_END_DATE := :OLD.SALE_END_DATE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.STORE_ITEMS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.stores (
    store_id              NUMBER NOT NULL,
    name                  VARCHAR2(255 BYTE),
    website               VARCHAR2(2000 BYTE),
    open_date             TIMESTAMP WITH LOCAL TIME ZONE,
    store_type            VARCHAR2(50 BYTE),
    location_address_id   NUMBER NOT NULL,
    legal_person_id       NUMBER NOT NULL
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.stores_pk ON
    mwd.stores (
        store_id
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.stores
    ADD CONSTRAINT stores_pk PRIMARY KEY ( store_id )
        USING INDEX mwd.stores_pk;


CREATE TABLE MWD.STORES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,STORE_ID NUMBER NOT NULL
 ,NAME VARCHAR2 (255 BYTE)
 ,WEBSITE VARCHAR2 (2000 BYTE)
 ,OPEN_DATE TIMESTAMP WITH LOCAL TIME ZONE
 ,STORE_TYPE VARCHAR2 (50 BYTE)
 ,LOCATION_ADDRESS_ID NUMBER NOT NULL
 ,LEGAL_PERSON_ID NUMBER NOT NULL
 );

CREATE OR REPLACE TRIGGER MWD.STORES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.STORES for each row 
 Declare 
  rec MWD.STORES_JN%ROWTYPE; 
  blank MWD.STORES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.STORE_ID := :NEW.STORE_ID; 
      rec.NAME := :NEW.NAME; 
      rec.WEBSITE := :NEW.WEBSITE; 
      rec.OPEN_DATE := :NEW.OPEN_DATE; 
      rec.STORE_TYPE := :NEW.STORE_TYPE; 
      rec.LOCATION_ADDRESS_ID := :NEW.LOCATION_ADDRESS_ID; 
      rec.LEGAL_PERSON_ID := :NEW.LEGAL_PERSON_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.STORE_ID := :OLD.STORE_ID; 
      rec.NAME := :OLD.NAME; 
      rec.WEBSITE := :OLD.WEBSITE; 
      rec.OPEN_DATE := :OLD.OPEN_DATE; 
      rec.STORE_TYPE := :OLD.STORE_TYPE; 
      rec.LOCATION_ADDRESS_ID := :OLD.LOCATION_ADDRESS_ID; 
      rec.LEGAL_PERSON_ID := :OLD.LEGAL_PERSON_ID; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.STORES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.tools (
    tool_id     NUMBER NOT NULL,
    tool_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.tools_pk ON
    mwd.tools (
        tool_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.tools
    ADD CONSTRAINT tools_pk PRIMARY KEY ( tool_id )
        USING INDEX mwd.tools_pk;


CREATE TABLE MWD.TOOLS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,TOOL_ID NUMBER NOT NULL
 ,TOOL_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.TOOLS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.TOOLS for each row 
 Declare 
  rec MWD.TOOLS_JN%ROWTYPE; 
  blank MWD.TOOLS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.TOOL_ID := :NEW.TOOL_ID; 
      rec.TOOL_TYPE := :NEW.TOOL_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.TOOL_ID := :OLD.TOOL_ID; 
      rec.TOOL_TYPE := :OLD.TOOL_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.TOOLS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.weave_ars (
    weave_ar_id     NUMBER NOT NULL,
    weave_id        NUMBER NOT NULL,
    optimal_ar      NUMBER(8, 2),
    min_ar          NUMBER(8, 2),
    max_ar          NUMBER(8, 2),
    ar_sort_order   NUMBER(8)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.weave_ars_pk ON
    mwd.weave_ars (
        weave_ar_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.weave_ars_uk ON
    mwd.weave_ars (
        weave_id
    ASC,
        optimal_ar
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.weave_ars
    ADD CONSTRAINT weave_ars_pk PRIMARY KEY ( weave_ar_id )
        USING INDEX mwd.weave_ars_pk;

ALTER TABLE mwd.weave_ars
    ADD CONSTRAINT weave_ars_uk UNIQUE ( weave_id,
                                         optimal_ar )
        USING INDEX mwd.weave_ars_uk;


CREATE TABLE MWD.WEAVE_ARS_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,WEAVE_AR_ID NUMBER NOT NULL
 ,WEAVE_ID NUMBER NOT NULL
 ,OPTIMAL_AR NUMBER (8,2)
 ,MIN_AR NUMBER (8,2)
 ,MAX_AR NUMBER (8,2)
 ,AR_SORT_ORDER NUMBER (8)
 );

CREATE OR REPLACE TRIGGER MWD.WEAVE_ARS_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.WEAVE_ARS for each row 
 Declare 
  rec MWD.WEAVE_ARS_JN%ROWTYPE; 
  blank MWD.WEAVE_ARS_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.WEAVE_AR_ID := :NEW.WEAVE_AR_ID; 
      rec.WEAVE_ID := :NEW.WEAVE_ID; 
      rec.OPTIMAL_AR := :NEW.OPTIMAL_AR; 
      rec.MIN_AR := :NEW.MIN_AR; 
      rec.MAX_AR := :NEW.MAX_AR; 
      rec.AR_SORT_ORDER := :NEW.AR_SORT_ORDER; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.WEAVE_AR_ID := :OLD.WEAVE_AR_ID; 
      rec.WEAVE_ID := :OLD.WEAVE_ID; 
      rec.OPTIMAL_AR := :OLD.OPTIMAL_AR; 
      rec.MIN_AR := :OLD.MIN_AR; 
      rec.MAX_AR := :OLD.MAX_AR; 
      rec.AR_SORT_ORDER := :OLD.AR_SORT_ORDER; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.WEAVE_ARS_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.weaves (
    weave_id          NUMBER NOT NULL,
    name              VARCHAR2(30 BYTE),
    synonyms          VARCHAR2(2000 BYTE),
    parent_weave_id   NUMBER,
    complexity        VARCHAR2(30 BYTE) DEFAULT 'BEGINNER',
    description       VARCHAR2(2000 BYTE),
    speed_weave       VARCHAR2(2000 BYTE),
    source_url        VARCHAR2(2000 BYTE)
)
TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.weaves_pk ON
    mwd.weaves (
        weave_id
    ASC )
        TABLESPACE bp NOLOGGING;

CREATE UNIQUE INDEX mwd.weaves_uk ON
    mwd.weaves (
        name
    ASC )
        TABLESPACE bp NOLOGGING;

ALTER TABLE mwd.weaves
    ADD CONSTRAINT weaves_pk PRIMARY KEY ( weave_id )
        USING INDEX mwd.weaves_pk;

ALTER TABLE mwd.weaves
    ADD CONSTRAINT weaves_uk UNIQUE ( name )
        USING INDEX mwd.weaves_uk;


CREATE TABLE MWD.WEAVES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,WEAVE_ID NUMBER NOT NULL
 ,NAME VARCHAR2 (30 BYTE)
 ,SYNONYMS VARCHAR2 (2000 BYTE)
 ,PARENT_WEAVE_ID NUMBER
 ,COMPLEXITY VARCHAR2 (30 BYTE)
 ,DESCRIPTION VARCHAR2 (2000 BYTE)
 ,SPEED_WEAVE VARCHAR2 (2000 BYTE)
 ,SOURCE_URL VARCHAR2 (2000 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.WEAVES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.WEAVES for each row 
 Declare 
  rec MWD.WEAVES_JN%ROWTYPE; 
  blank MWD.WEAVES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.WEAVE_ID := :NEW.WEAVE_ID; 
      rec.NAME := :NEW.NAME; 
      rec.SYNONYMS := :NEW.SYNONYMS; 
      rec.PARENT_WEAVE_ID := :NEW.PARENT_WEAVE_ID; 
      rec.COMPLEXITY := :NEW.COMPLEXITY; 
      rec.DESCRIPTION := :NEW.DESCRIPTION; 
      rec.SPEED_WEAVE := :NEW.SPEED_WEAVE; 
      rec.SOURCE_URL := :NEW.SOURCE_URL; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.WEAVE_ID := :OLD.WEAVE_ID; 
      rec.NAME := :OLD.NAME; 
      rec.SYNONYMS := :OLD.SYNONYMS; 
      rec.PARENT_WEAVE_ID := :OLD.PARENT_WEAVE_ID; 
      rec.COMPLEXITY := :OLD.COMPLEXITY; 
      rec.DESCRIPTION := :OLD.DESCRIPTION; 
      rec.SPEED_WEAVE := :OLD.SPEED_WEAVE; 
      rec.SOURCE_URL := :OLD.SOURCE_URL; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.WEAVES_JN VALUES rec; 
  END; 
/

CREATE TABLE mwd.wires (
    wire_id     NUMBER NOT NULL,
    wire_type   VARCHAR2(45 BYTE)
)
TABLESPACE bp LOGGING;

CREATE UNIQUE INDEX mwd.wires_pk ON
    mwd.wires (
        wire_id
    ASC )
        TABLESPACE bp LOGGING;

ALTER TABLE mwd.wires
    ADD CONSTRAINT wires_pk PRIMARY KEY ( wire_id )
        USING INDEX mwd.wires_pk;


CREATE TABLE MWD.WIRES_JN
 (JN_OPERATION CHAR(3) NOT NULL
 ,JN_ORACLE_USER VARCHAR2(30) NOT NULL
 ,JN_DATETIME DATE NOT NULL
 ,JN_NOTES VARCHAR2(240)
 ,JN_APPLN VARCHAR2(35)
 ,JN_SESSION NUMBER(38)
 ,WIRE_ID NUMBER NOT NULL
 ,WIRE_TYPE VARCHAR2 (45 BYTE)
 );

CREATE OR REPLACE TRIGGER MWD.WIRES_JNtrg
  AFTER 
  INSERT OR 
  UPDATE OR 
  DELETE ON MWD.WIRES for each row 
 Declare 
  rec MWD.WIRES_JN%ROWTYPE; 
  blank MWD.WIRES_JN%ROWTYPE; 
  BEGIN 
    rec := blank; 
    IF INSERTING OR UPDATING THEN 
      rec.WIRE_ID := :NEW.WIRE_ID; 
      rec.WIRE_TYPE := :NEW.WIRE_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      IF INSERTING THEN 
        rec.JN_OPERATION := 'INS'; 
      ELSIF UPDATING THEN 
        rec.JN_OPERATION := 'UPD'; 
      END IF; 
    ELSIF DELETING THEN 
      rec.WIRE_ID := :OLD.WIRE_ID; 
      rec.WIRE_TYPE := :OLD.WIRE_TYPE; 
      rec.JN_DATETIME := SYSDATE; 
      rec.JN_ORACLE_USER := SYS_CONTEXT ('USERENV', 'SESSION_USER'); 
      rec.JN_APPLN := SYS_CONTEXT ('USERENV', 'MODULE'); 
      rec.JN_SESSION := SYS_CONTEXT ('USERENV', 'SESSIONID'); 
      rec.JN_OPERATION := 'DEL'; 
    END IF; 
    INSERT into MWD.WIRES_JN VALUES rec; 
  END;
/

ALTER TABLE mwd.accessories
    ADD CONSTRAINT accessories_fk FOREIGN KEY ( created_item_id )
        REFERENCES mwd.created_items ( created_item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.attachments
    ADD CONSTRAINT attachments_fk FOREIGN KEY ( attachment_id )
        REFERENCES mwd.crafted_ingredients ( crafted_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.beads
    ADD CONSTRAINT beads_fk FOREIGN KEY ( bead_id )
        REFERENCES mwd.crafted_ingredients ( crafted_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.chains
    ADD CONSTRAINT chains_fk FOREIGN KEY ( chain_id )
        REFERENCES mwd.raw_ingredients ( raw_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.clasps
    ADD CONSTRAINT clasps_fk FOREIGN KEY ( clasp_id )
        REFERENCES mwd.crafted_ingredients ( crafted_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.crafted_ingredients
    ADD CONSTRAINT crafted_ingredients_fk FOREIGN KEY ( crafted_ingredient_id )
        REFERENCES mwd.ingredients ( ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.crafted_ingredients
    ADD CONSTRAINT crafted_ingredients_fk2 FOREIGN KEY ( raw_ingredient_id )
        REFERENCES mwd.raw_ingredients ( raw_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.created_items
    ADD CONSTRAINT created_items_fk FOREIGN KEY ( created_item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.domains
    ADD CONSTRAINT domains_fk FOREIGN KEY ( parent_domain_value_id )
        REFERENCES mwd.domains ( domain_value_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_fk FOREIGN KEY ( ingredient_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_fk2 FOREIGN KEY ( wire_diameter_swg )
        REFERENCES mwd.standard_wire_gauges ( swg )
    NOT DEFERRABLE;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_fk3 FOREIGN KEY ( wire_diameter_awg )
        REFERENCES mwd.american_wire_gauges ( awg )
    NOT DEFERRABLE;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_fk4 FOREIGN KEY ( inner_diameter_inch )
        REFERENCES mwd.imperial_fractions ( inch_fraction )
    NOT DEFERRABLE;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_fk5 FOREIGN KEY ( material )
        REFERENCES mwd.materials ( abbreviation )
    NOT DEFERRABLE;

ALTER TABLE mwd.ingredients
    ADD CONSTRAINT ingredients_fk6 FOREIGN KEY ( color )
        REFERENCES mwd.colors ( name )
    NOT DEFERRABLE;

ALTER TABLE mwd.item_ingredients
    ADD CONSTRAINT item_ingredients_fk FOREIGN KEY ( item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.item_ingredients
    ADD CONSTRAINT item_ingredients_fk2 FOREIGN KEY ( ingredient_id )
        REFERENCES mwd.ingredients ( ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.item_order_sources
    ADD CONSTRAINT item_order_sources_fk FOREIGN KEY ( item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.item_weaves
    ADD CONSTRAINT item_weaves_fk FOREIGN KEY ( weave_id )
        REFERENCES mwd.weaves ( weave_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.item_weaves
    ADD CONSTRAINT item_weaves_fk2 FOREIGN KEY ( item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.item_weaves
    ADD CONSTRAINT item_weaves_fk3 FOREIGN KEY ( ingredient_id )
        REFERENCES mwd.ingredients ( ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.jewelry
    ADD CONSTRAINT jewelry_fk FOREIGN KEY ( created_item_id )
        REFERENCES mwd.created_items ( created_item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.kit_items
    ADD CONSTRAINT kit_items_fk FOREIGN KEY ( kit_id )
        REFERENCES mwd.kits ( kit_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.kit_items
    ADD CONSTRAINT kit_items_fk2 FOREIGN KEY ( item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.kits
    ADD CONSTRAINT kits_fk FOREIGN KEY ( kit_id )
        REFERENCES mwd.items ( item_id )
    NOT DEFERRABLE;

ALTER TABLE mwd.lace
    ADD CONSTRAINT lace_fk FOREIGN KEY ( lace_id )
        REFERENCES mwd.raw_ingredients ( raw_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.legal_persons
    ADD CONSTRAINT legal_persons_fk FOREIGN KEY ( person_id )
        REFERENCES mwd.persons ( person_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.location_addresses
    ADD CONSTRAINT location_addresses_fk FOREIGN KEY ( location_id )
        REFERENCES mwd.locations ( location_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.natural_persons
    ADD CONSTRAINT natural_persons_fk FOREIGN KEY ( person_id )
        REFERENCES mwd.persons ( person_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.order_items
    ADD CONSTRAINT order_items_fk FOREIGN KEY ( order_id )
        REFERENCES mwd.orders ( order_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.order_items
    ADD CONSTRAINT order_items_fk2 FOREIGN KEY ( item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.orders
    ADD CONSTRAINT orders_fk FOREIGN KEY ( person_id )
        REFERENCES mwd.persons ( person_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.orders
    ADD CONSTRAINT orders_fk2 FOREIGN KEY ( location_address_id )
        REFERENCES mwd.location_addresses ( location_address_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.ornaments
    ADD CONSTRAINT ornaments_fk FOREIGN KEY ( created_item_id )
        REFERENCES mwd.created_items ( created_item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.other_ingredients
    ADD CONSTRAINT other_ingredients_fk FOREIGN KEY ( other_ingredient_id )
        REFERENCES mwd.ingredients ( ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.other_items
    ADD CONSTRAINT other_items_fk FOREIGN KEY ( other_item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.locations
    ADD CONSTRAINT locations_fk FOREIGN KEY ( person_id )
        REFERENCES mwd.persons ( person_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.purchases
    ADD CONSTRAINT purchases_fk FOREIGN KEY ( order_id )
        REFERENCES mwd.orders ( order_id )
    NOT DEFERRABLE;

ALTER TABLE mwd.raw_ingredients
    ADD CONSTRAINT raw_ingredients_fk FOREIGN KEY ( raw_ingredient_id )
        REFERENCES mwd.ingredients ( ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.rings
    ADD CONSTRAINT rings_fk FOREIGN KEY ( ring_id )
        REFERENCES mwd.crafted_ingredients ( crafted_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.sales
    ADD CONSTRAINT sales_fk FOREIGN KEY ( order_id )
        REFERENCES mwd.orders ( order_id )
    NOT DEFERRABLE;

ALTER TABLE mwd.scales
    ADD CONSTRAINT scales_fk FOREIGN KEY ( scale_id )
        REFERENCES mwd.crafted_ingredients ( crafted_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.set_items
    ADD CONSTRAINT set_items_fk FOREIGN KEY ( set_id )
        REFERENCES mwd.sets ( set_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.set_items
    ADD CONSTRAINT set_items_fk2 FOREIGN KEY ( created_item_id )
        REFERENCES mwd.created_items ( created_item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.sets
    ADD CONSTRAINT sets_items_fk FOREIGN KEY ( set_id )
        REFERENCES mwd.items ( item_id )
    NOT DEFERRABLE;

ALTER TABLE mwd.store_items
    ADD CONSTRAINT store_items_fk FOREIGN KEY ( item_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.store_items
    ADD CONSTRAINT store_items_fk2 FOREIGN KEY ( store_id )
        REFERENCES mwd.stores ( store_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.stores
    ADD CONSTRAINT stores_fk FOREIGN KEY ( location_address_id )
        REFERENCES mwd.location_addresses ( location_address_id )
    NOT DEFERRABLE;

ALTER TABLE mwd.stores
    ADD CONSTRAINT stores_fk2 FOREIGN KEY ( legal_person_id )
        REFERENCES mwd.legal_persons ( person_id )
    NOT DEFERRABLE;

ALTER TABLE mwd.tools
    ADD CONSTRAINT tools_fk FOREIGN KEY ( tool_id )
        REFERENCES mwd.items ( item_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.weave_ars
    ADD CONSTRAINT weave_ars_fk FOREIGN KEY ( weave_id )
        REFERENCES mwd.weaves ( weave_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.weaves
    ADD CONSTRAINT weaves_fk FOREIGN KEY ( parent_weave_id )
        REFERENCES mwd.weaves ( weave_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;

ALTER TABLE mwd.wires
    ADD CONSTRAINT wires_fk FOREIGN KEY ( wire_id )
        REFERENCES mwd.raw_ingredients ( raw_ingredient_id )
            ON DELETE CASCADE
    NOT DEFERRABLE;


CREATE OR REPLACE TRIGGER MWD.DOMAINS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.DOMAINS 
    FOR EACH ROW 
DECLARE 
  domn_value_id number; 
  name_count number;
  value_in_list number;
BEGIN 
  if inserting then   
    if :new.domain_value_id is null then 
      select domn_seq.nextval 
        into domn_value_id 
        from dual; 
      :new.domain_value_id := domn_value_id; 
    end if; 

	if :new.sort_order is null then
		select nvl(max(domain_value_id),0)
			into name_count
			from domains
			where domain_name = :new.domain_name;		
		:new.sort_order := name_count + 1;
	end if;

	-- in lieu of check constraint.
	if :new.domain_type is not null then
		select nvl(count(*),0)
			into value_in_list
			from domains
			where domain_name = 'DOMAIN_TYPE'
			and domain_value = :new.domain_type;
		if (value_in_list = 0) then -- treat as if null to assign default.
			:new.domain_type := null;
		end if;
	end if;

	:new.user_created := user;
    :new.date_created := SYSDATE;
    :new.user_modified := user;
    :new.date_modified := SYSDATE;
  elsif updating THEN
    :new.user_modified := user;
    :new.date_modified := SYSDATE;
  end if;

END; 
/

CREATE OR REPLACE TRIGGER MWD.INGREDIENTS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.INGREDIENTS 
    FOR EACH ROW 
DECLARE 
  ingr_id number;
  value_in_col_list number;
  value_in_mat_list number;
  value_in_cat_list number;
  value_in_ava_list number;
  value_in_sal_list number;
  cat_id number;
  is_active char(1);
  default_subcat varchar2(30) := 'OTHER';
BEGIN 

	-- IN LIEU OF CHECK CONSTRAINTS
	if :new.material is not null then
		select nvl(count(*),0)
			into value_in_mat_list
			from domains
			where domain_name = 'ITEM_MATERIAL'
			and active = 'Y'
			and domain_value = :new.material;

			if (value_in_mat_list = 0) then -- treat as if null to assign default.
				:new.material := null;
			end if;
	end if;

	if :new.color is not null then
		select nvl(count(*),0)
			into value_in_col_list
			from domains
			where domain_name = 'ITEM_COLOR'
			and active = 'Y'
			and domain_value = :new.color;

			if (value_in_col_list = 0) then -- treat as if null to assign default.
				:new.color := null;
			end if;
	end if;

  	if :new.ingredient_type is not null then
		select domain_value_id, active 
			into cat_id, is_active
			from domains 
			where domain_name = 'INGREDIENT_CATEGORY'
			and domain_value = :new.ingredient_type;

		if (is_active = 'Y') then
			select domain_value
			into default_subcat
			from domains
			group by domain_value
			having sort_order = min(sort_order)  -- take lowest sequence value in domain.
			and domain_name = 'INGREDIENT_SUBCATEGORY'
			and active = 'Y'
			and parent_domain_value_id = cat_id;

		else -- if category <> active, treat as null.
			:new.ingredient_type := null;
		end if;
	end if;

    IF :NEW.WIRE_DIAMETER_MM IS NOT NULL THEN
		SELECT A1.AWG
		INTO :NEW.WIRE_DIAMETER_AWG
		FROM AMERICAN_WIRE_GAUGES A1
		, AMERICAN_WIRE_GAUGES A2
		WHERE :new.wire_diameter_mm 
			BETWEEN A1.DIAMETER_MM AND A2.DIAMETER_MM;

		SELECT S1.SWG
		INTO :NEW.WIRE_DIAMETER_SWG
		FROM STANDARD_WIRE_GAUGES S1
		, STANDARD_WIRE_GAUGES S2
		WHERE :new.wire_diameter_mm 
			BETWEEN S1.DIAMETER_MM AND S2.DIAMETER_MM;

		IF :NEW.INNER_DIAMETER_MM IS NOT NULL THEN
			:NEW.ASPECT_RATIO := :new.inner_diameter_mm / :new.wire_diameter_mm;
			if :new.outer_diameter_mm is not null then
				:NEW.OUTER_DIAMETER_MM := (:new.wire_diameter_mm * 2) + :new.inner_diameter_mm;
			end if;
		END IF;
	END IF;
END; 
/


CREATE OR REPLACE TRIGGER MWD.ITEM_INGREDIENTS_AIUD 
    AFTER INSERT OR UPDATE OR DELETE ON MWD.ITEM_INGREDIENTS 
begin 
  -- Update the Product Cost Total when any product ingredient is changed 
  update items set cost_total = 
  (select sum(unit_price*quantity) from item_ingredients 
    where item_ingredients.item_id = items.item_id); 
end; 
/

CREATE OR REPLACE TRIGGER MWD.ITEM_INGREDIENTS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.ITEM_INGREDIENTS 
    FOR EACH ROW 
declare 
  item_ingredient_id number; 
  l_list_price number; 
begin 
  if inserting then
    if :new.item_ingredient_id is null then 
		select item_ingr_seq.nextval  
			into item_ingredient_id  
			from dual; 
		:new.item_ingredient_id := item_ingredient_id; 
	end if; 
  end if;

  if (:new.unit_price is null OR :new.unit_price = 0) then 
    -- First, we need to get the current list price of the product ingredient 
    select nvl(list_price,0)
    into l_list_price 
    from items 
    where item_id = :new.ingredient_id; 
    -- Once we have the correct price, we will update the product ingredient with the correct price 
    :new.unit_price := l_list_price; 
  end if; 
end; 
/


CREATE OR REPLACE TRIGGER MWD.ITEM_ORDER_SOURCES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.ITEM_ORDER_SOURCES 
    FOR EACH ROW 
DECLARE 
  item_order_source_id number; 
BEGIN 
  if inserting then   
    if :new.item_order_source_id is null then 
      select item_ordr_srce_seq.nextval 
        into item_order_source_id 
        from dual; 
      :new.item_order_source_id := item_order_source_id; 
    end if; 
  end if; 

END; 
/


CREATE OR REPLACE TRIGGER MWD.ITEM_WEAVES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.ITEM_WEAVES 
    FOR EACH ROW 
declare 
  item_weave_id number; 
begin 
  if inserting then
    if :new.item_weave_id is null then 
		select item_weav_seq.nextval  
			into item_weave_id  
			from dual; 
		:new.item_weave_id := item_weave_id; 
	end if; 
  end if;
end; 
/


CREATE OR REPLACE TRIGGER MWD.ITEMS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.ITEMS 
    FOR EACH ROW 
DECLARE 
  prod_id number;
  is_active char(1);
  default_subcat varchar2(30) := 'OTHER';
  cat_id number;
  value_in_cat_list number;
  value_in_ava_list number;
  value_in_sal_list number;
BEGIN 
  if inserting then   
    if :new.item_id is null then 
      select item_seq.nextval 
        into prod_id 
        from dual; 
      :new.item_id := prod_id; 
    end if; 
  end if; 

  	-- in lieu of check constraint.
	if :new.availability is not null then
		select nvl(count(*),0)
			into value_in_ava_list
			from domains
			where domain_name = 'ITEM_AVAILABILITY'
			and active = 'Y'
			and domain_value = :new.availability;

		if (value_in_ava_list = 0) then -- treat as if null.
			:new.availability := null;
		end if;
	end if; 

	if :new.sale_status is not null then
		select nvl(count(*),0)
			into value_in_sal_list
			from domains
			where domain_name = 'ITEM_SALE_STATUS'
			and active = 'Y'
			and domain_value = :new.sale_status;

		if (value_in_sal_list = 0) then -- treat as if null.
			:new.sale_status := null;
		end if;
	end if;   

  if :new.item_type is not null then
		select domain_value_id, active 
			into cat_id, is_active
			from domains 
			where domain_name = 'ITEM_CATEGORY' 
			and domain_value = :new.item_type;

		if (is_active = 'Y') then
			select domain_value
			into default_subcat
			from domains
			group by domain_value
			having sort_order = min(sort_order)  -- take lowest sequence value in domain.
			and domain_name = 'ITEM_SUBCATEGORY'
			and active = 'Y'
			and parent_domain_value_id = cat_id;

		else -- if category <> active, treat as null.
			:new.item_type := null;
		end if;
	end if;
END; 
/

CREATE OR REPLACE TRIGGER MWD.KIT_ITEMS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.KIT_ITEMS 
    FOR EACH ROW 
declare
  kit_item_id number;  
  l_list_price number; 
begin 
  if inserting then
	  if :new.kit_item_id is null then 
		select kit_item_seq.nextval  
		  into kit_item_id  
		  from dual; 
		:new.kit_item_id := kit_item_id; 
	  end if;
  end if; 

  if :new.unit_price is null then 
	if :new.item_id is not null 
			then
		select list_price 
		into l_list_price 
		from items 
		where item_id = :new.item_id; 	
	else
		l_list_price := 0; -- ELSE CLAUSE TO CATCH EMPTY INSERTS.
	end if;

	:new.unit_price := l_list_price;
  end if; 
end; 
/

create or replace TRIGGER MWD.KIT_ITEMS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.KIT_ITEMS 
    FOR EACH ROW 
declare
  kit_item_id number;  
  l_list_price number; 
begin 
  if :new.unit_price is null then 
	if :new.item_id is not null 
			then
		select list_price 
		into l_list_price 
		from items 
		where item_id = :new.item_id; 	
	else
		l_list_price := 0; -- ELSE CLAUSE TO CATCH EMPTY INSERTS.
	end if;

	:new.unit_price := l_list_price;
  end if; 
end; 
/


CREATE OR REPLACE TRIGGER MWD.KITS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.KITS 
    FOR EACH ROW 
DECLARE 
  kit_id number;
  value_in_ava_list number;
  value_in_sal_list number;
BEGIN 

    	-- in lieu of check constraint.
	if :new.availability is not null then
		select nvl(count(*),0)
			into value_in_ava_list
			from domains
			where domain_name = 'ITEM_AVAILABILITY'
			and active = 'Y'
			and domain_value = :new.availability;

		if (value_in_ava_list = 0) then -- treat as if null.
			:new.availability := null;
		end if;
	end if; 

	if :new.sale_status is not null then
		select nvl(count(*),0)
			into value_in_sal_list
			from domains
			where domain_name = 'ITEM_SALE_STATUS'
			and active = 'Y'
			and domain_value = :new.sale_status;

		if (value_in_sal_list = 0) then -- treat as if null.
			:new.sale_status := null;
		end if;
	end if;   
END; 
/


CREATE OR REPLACE TRIGGER MWD.LOCATION_ADDRESSES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.LOCATION_ADDRESSES 
    FOR EACH ROW 
DECLARE 
  location_address_id number; 
BEGIN 
  if inserting then   
    if :new.location_address_id is null then 
      select loc_addr_seq.nextval 
        into location_address_id 
        from dual; 
      :new.location_address_id := location_address_id; 
    end if; 
  end if; 

END; 
/


CREATE OR REPLACE TRIGGER MWD.LOCATIONS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.LOCATIONS 
    FOR EACH ROW 
DECLARE
	location_id number;
BEGIN 
   if inserting then 
	if :new.location_id is null then 
      select loc_seq.nextval 
        INTO location_id
        FROM dual; 
      :new.location_id := location_id;   
	end if;
   end if; 
END; 
/


CREATE OR REPLACE TRIGGER MWD.NATURAL_PERSONS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.NATURAL_PERSONS 
    FOR EACH ROW 
BEGIN 
  if inserting then   
	if (:new.first_name is null 
		OR :new.first_name = 'ANONYMOUS')
		AND :new.last_name is null
		then
			select d1.domain_value, d2.domain_value
			into :new.first_name, :new.last_name
			from domains d1 , domains d2
			where d1.domain_name = 'DEFAULT_CUST_FN'
			and d2.domain_name = 'DEFAULT_CUST_LN'
			;
	end if;
  end if; 
END; 
/


CREATE OR REPLACE TRIGGER MWD.ORDER_ITEMS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.ORDER_ITEMS 
    FOR EACH ROW 
declare
  order_item_id number;  
  l_list_price number; 
begin 
  if inserting then
	  if :new.order_item_id is null then 
		select ordr_item_seq.nextval  
		  into order_item_id  
		  from dual; 
		:new.order_item_id := order_item_id; 
	  end if;
  end if; 

  if :new.unit_price is null then 
	if :new.item_id is not null 
			then
		select list_price 
		into l_list_price 
		from items 
		where item_id = :new.item_id; 
	else
		l_list_price := 0; -- ELSE CLAUSE TO LEAVE SPACE FOR NEW ORDER_ITEMS LIKE KITS/SETS.
	end if;
  end if; 
end; 
/


CREATE OR REPLACE TRIGGER MWD.ORDERS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.ORDERS 
    FOR EACH ROW 
DECLARE 
  order_id number; 
  value_in_list number;
BEGIN 
  if inserting then   
    if :new.order_id is null then 
      select ordr_seq.nextval 
        INTO order_id 
        FROM dual; 
      :new.order_id := order_id; 
    end if;
  end if; 

 	-- in lieu of check constraint.
	if :new.order_type is not null then
		select nvl(count(*),0)
			into value_in_list
			from domains
			where domain_name = 'ORDER_TYPE'
			and active = 'Y';
		if (value_in_list = 0) then
			:new.order_type := null;
		end if;
	end if;

END; 
/


CREATE OR REPLACE TRIGGER MWD.PERSONS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.PERSONS 
    FOR EACH ROW 
DECLARE 
	pers_id 	number; 
BEGIN 
  if inserting then   
    if :new.person_id is null then 
      select pers_seq.nextval 
        into pers_id 
        from dual; 
      :new.person_id := pers_id; 
    end if; 
  end if; 
END; 
/


CREATE OR REPLACE TRIGGER MWD.PURCHASES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.PURCHASES 
    FOR EACH ROW 
DECLARE
    value_in_list number;
BEGIN
	if :new.order_status is not null then
		select nvl(count(*),0)
			into value_in_list
			from domains
			where domain_name = 'PURCHASE_STATUS'
			and active = 'Y';
		if (value_in_list = 0) then
			:new.order_status := null;
		end if;
	end if;
END; 
/


CREATE OR REPLACE TRIGGER MWD.SALES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.SALES 
    FOR EACH ROW 
DECLARE
    value_in_list number;
BEGIN
	if :new.order_status is not null then
		select nvl(count(*),0)
			into value_in_list
			from domains
			where domain_name = 'SALE_STATUS'
			and active = 'Y';
		if (value_in_list = 0) then
			:new.order_status := null;
		end if;
	end if;
END; 
/


CREATE OR REPLACE TRIGGER MWD.SET_ITEMS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.SET_ITEMS 
    FOR EACH ROW 
declare
  set_item_id number;  
  l_list_price number; 
begin 
  if inserting then
	  if :new.set_item_id is null then 
		select set_item_seq.nextval  
		  into set_item_id  
		  from dual; 
		:new.set_item_id := set_item_id; 
	  end if;
  end if; 

  if :new.unit_price is null then 
	if :new.created_item_id is not null
			then
		select list_price 
		into l_list_price 
		from items 
		where item_id = :new.created_item_id;
	else
		l_list_price := 0; -- ELSE CLAUSE TO CATCH EMPTY INSERTS.
	end if;

	:new.unit_price := l_list_price;
  end if; 
end; 
/


CREATE OR REPLACE TRIGGER MWD.SETS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.SETS 
    FOR EACH ROW 
DECLARE 
  set_id number;
  value_in_ava_list number;
  value_in_sal_list number;
BEGIN 

      	-- in lieu of check constraint.
	if :new.availability is not null then
		select nvl(count(*),0)
			into value_in_ava_list
			from domains
			where domain_name = 'ITEM_AVAILABILITY'
			and active = 'Y'
			and domain_value = :new.availability;

		if (value_in_ava_list = 0) then -- treat as if null.
			:new.availability := null;
		end if;
	end if; 

	if :new.sale_status is not null then
		select nvl(count(*),0)
			into value_in_sal_list
			from domains
			where domain_name = 'ITEM_SALE_STATUS'
			and active = 'Y'
			and domain_value = :new.sale_status;

		if (value_in_sal_list = 0) then -- treat as if null.
			:new.sale_status := null;
		end if;
	end if;   
END; 
/


CREATE OR REPLACE TRIGGER MWD.STORE_ITEMS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.STORE_ITEMS 
    FOR EACH ROW 
DECLARE
	store_item_id	number;
	l_list_price		number;
BEGIN 
   if inserting then 
   	  if :new.store_item_id is null then 
		select stor_item_seq.nextval  
		  into store_item_id  
		  from dual; 
		:new.store_item_id := store_item_id;
	  end if;
   end if; 

   if :new.unit_price is null then 
    -- First, we need to get the current list price of the store item 
	if :new.item_id is not null 
        then
		select list_price 
		into l_list_price 
		from items 
		where item_id = :new.item_id; 
	else
		l_list_price := 0; -- ELSE CLAUSE TO LEAVE SPACE FOR NEW STORE_ITEMS LIKE KITS/SETS.
	end if;
    -- Once we have the correct price, we will update the store item with the correct price 
    :new.unit_price := l_list_price; 
  end if; 
END; 
/


CREATE OR REPLACE TRIGGER MWD.STORES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.STORES 
    FOR EACH ROW 
DECLARE
	value_in_list number;
	store_id number;
BEGIN 
   if inserting then 
	if :new.store_id is null then 
      select stor_seq.nextval 
        INTO store_id 
        FROM dual; 
      :new.store_id := store_id;   
	end if;
   end if; 

 	-- in lieu of check constraint.
	if :new.store_type is not null then
		select nvl(count(*),0)
			into value_in_list
			from domains
			where domain_name = 'STORE_TYPE'
			and active = 'Y';
		if (value_in_list = 0) then
			:new.store_type := null;
		end if;
	end if;   
END; 
/


CREATE OR REPLACE TRIGGER MWD.WEAVE_ARS_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.WEAVE_ARS 
    FOR EACH ROW 
DECLARE 
  weave_ar_order number; 
  weav_ar_id number; 
BEGIN 
  if inserting then   
    if :new.weave_ar_id is null then 
      select weav_ar_seq.nextval 
        into weav_ar_id 
        from dual; 
      :new.weave_ar_id := weav_ar_id; 
    end if; 

    if :new.ar_sort_order is null then 
      select nvl(max(ar_sort_order), 0)
	  into weave_ar_order
	  from weave_ars
	  where weave_id=:new.weave_id;

      :new.ar_sort_order := weave_ar_order +1; 
    end if; 
  end if; 
END; 
/


CREATE OR REPLACE TRIGGER MWD.WEAVES_BRIU 
    BEFORE INSERT OR UPDATE ON MWD.WEAVES 
    FOR EACH ROW 
DECLARE 
  weav_id number; 
  value_in_list number;
BEGIN 
  if inserting then   
    if :new.weave_id is null then 
      select weav_seq.nextval 
        into weav_id 
        from dual; 
      :new.weave_id := weav_id; 
    end if; 
  end if; 

  	-- in lieu of check constraint.
	if :new.complexity is not null then
		select nvl(count(*),0)
			into value_in_list
			from domains
			where domain_name = 'WEAVE_COMPLEXITY'
			and active = 'Y';
		if (value_in_list = 0) then
			:new.complexity := null;
		end if;
	end if;

END; 
/


-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                            45
-- CREATE INDEX                            69
-- ALTER TABLE                            173
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          68
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                         33
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
